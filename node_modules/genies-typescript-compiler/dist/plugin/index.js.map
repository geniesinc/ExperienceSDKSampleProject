{"version":3,"file":"index.js","mappings":"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","sources":["file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/webpack/universalModuleDefinition","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/index.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/CSharpOperatorOverloadingSupress.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesLifecycleEvents.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/CompilerUtils.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/MethodOverloadUtils.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/GeniesDiagnosticsUtils.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/OperatorOverloadingUtils.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesLSPContext.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesScriptTypeDiagnostics.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/external commonjs \"ts-morph\"","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesLifecycleEventsCompletions.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesLifecycleEventsDiagnostics.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesInheritanceDiagnostics.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/external node-commonjs \"path\"","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/external commonjs \"typescript/lib/tsserverlibrary\"","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/webpack/bootstrap","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"genies-typescript-compiler-plugin\"] = factory();\n\telse\n\t\troot[\"genies-typescript-compiler-plugin\"] = factory();\n})(this, () => {\nreturn ","import ts from 'typescript/lib/tsserverlibrary';\nimport { Project } from 'ts-morph';\nimport { tss } from './types';\nimport { ILanguageServiceFeature } from \"./ILanguageServiceFeature\";\nimport { GeniesLifecycleEventsCompletions } from \"./GeniesLifecycleEventsCompletions\";\nimport { CSharpOperatorOverloadingSuppress } from \"./CSharpOperatorOverloadingSupress\";\nimport { GeniesLifecycleEventsDiagnostics } from \"./GeniesLifecycleEventsDiagnostics\";\nimport { GeniesScriptTypeDiagnostics } from \"./GeniesScriptTypeDiagnostics\";\nimport { GeniesLSPContext } from \"./GeniesLSPContext\";\nimport { GeniesSemanticDiagnostics } from \"./GeniesInheritanceDiagnostics\";\nimport {setProjectRoot} from \"../CompilerUtils\";\n\nconst init = (modules: { typescript: tss }) => {\n    let project: Project;\n    let context: GeniesLSPContext;\n\n    function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n        info.project.projectService.logger.info(\"I'm getting set up now! Check the log for this message.\");\n\n        // Create a ts-morph project using the existing tsconfig\n        project = new Project({\n            compilerOptions: info.project.getCompilerOptions(),\n            skipAddingFilesFromTsConfig: true,\n        });\n\n        setProjectRoot(project.getFileSystem().getCurrentDirectory());\n\n        context = new GeniesLSPContext(project, info);\n\n        const features: ILanguageServiceFeature[] = [\n            new GeniesLifecycleEventsCompletions(context),\n            new CSharpOperatorOverloadingSuppress(context),\n            new GeniesLifecycleEventsDiagnostics(context),\n            new GeniesScriptTypeDiagnostics(context),\n            new GeniesSemanticDiagnostics(context)\n            // Add other features here\n        ];\n\n        const proxy: ts.LanguageService = Object.create(null);\n        for (const k of Object.keys(info.languageService) as Array<keyof ts.LanguageService>) {\n            const x = info.languageService[k]!;\n            //@ts-expect-error\n            proxy[k] = (...args: Array<{}>) => x.apply(info.languageService, args);\n        }\n\n        features.forEach(feature => feature.enhanceProxy(proxy));\n        return proxy;\n    }\n\n    return { create };\n}\n\nexport = init;\n","import {LanguageService} from \"typescript\";\nimport {ILanguageServiceFeature} from \"./ILanguageServiceFeature\";\nimport {Node, SourceFile, SyntaxKind, Type} from \"ts-morph\";\nimport ts from \"typescript/lib/tsserverlibrary\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\nimport {getOperatorNodeReturnType} from \"../OperatorOverloadingUtils\";\n\ntype getSemanticDiagnostics = (fileName: string) => ts.Diagnostic[];\n\nexport class CSharpOperatorOverloadingSuppress implements ILanguageServiceFeature {\n    private expressionValidity: Array<{ start: number; end: number; valid: boolean }> = [];\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: LanguageService): void {\n        const originalGetSemanticDiagnostics = proxy.getSemanticDiagnostics;\n        proxy.getSemanticDiagnostics = (fileName: string): ts.Diagnostic[] => {\n            return this.getSemanticDiagnostics(originalGetSemanticDiagnostics, fileName);\n        };\n    }\n    \n    getSemanticDiagnostics(previousGetter: getSemanticDiagnostics, fileName: string): ts.Diagnostic[] {\n        const priorDiagnostics = previousGetter(fileName);\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return priorDiagnostics;\n        }\n\n        // Collect all expressions and their validity\n        this.collectExpressions(sourceFile);\n\n        const diagnostics = priorDiagnostics.filter(diagnostic => {\n            const start = diagnostic.start ?? 0;\n            const end = (diagnostic.start ?? 0) + (diagnostic.length ?? 0);\n\n            // If this diagnostic is contained in ANY recognized expression range, suppress it\n            for (const expr of this.expressionValidity) {\n                if (expr.valid && start >= expr.start && end <= expr.end) {\n                    return false;\n                }\n            }\n            return true;\n        });\n\n        // Clear the map for the next file\n        this.expressionValidity = [];\n        return diagnostics;\n    }\n    \n    isCastable(fromType: Type, toType: Type) : boolean {\n        // up to you, possibly a naive \"context.TypeChecker.isTypeAssignableTo(...)\"\n        // or your own custom rules\n        return fromType.isAssignableTo(toType);\n    }\n\n    collectExpressions(sourceFile: SourceFile) {\n        const binaryExpressions = sourceFile!.getDescendantsOfKind(SyntaxKind.BinaryExpression);\n        const prefixUnaryExpressions = sourceFile!.getDescendantsOfKind(SyntaxKind.PrefixUnaryExpression);\n        const postfixUnaryExpressions = sourceFile!.getDescendantsOfKind(SyntaxKind.PostfixUnaryExpression);\n\n        const processNode = (node: Node) => {\n            const start = node.getStart();\n            const end = node.getEnd();\n            const finalType = getOperatorNodeReturnType(node, this.context);\n\n            const valid = finalType != null;\n            this.context.Logger.info(`[FOUND TYPE] ${finalType?.getText()} at Node ${node.getText()}`);\n\n            // Just push it without skipping\n            this.expressionValidity.push({ start, end, valid });\n        };\n\n        binaryExpressions.forEach(processNode);\n        prefixUnaryExpressions.forEach(processNode);\n        postfixUnaryExpressions.forEach(processNode);\n\n        const assignmentExpressions = binaryExpressions.filter(expr => {\n            return expr.getOperatorToken().getKind() === SyntaxKind.EqualsToken;\n        });\n\n        for (const assign of assignmentExpressions) {\n            const rhs = assign.getRight();\n            const rhsStart = rhs.getStart();\n            const rhsEnd = rhs.getEnd();\n\n            // Check if the right side was recognized as valid\n            const recognized = this.expressionValidity.some(\n                expr => expr.valid && expr.start <= rhsStart && expr.end >= rhsEnd\n            );\n            if (recognized) {\n                // Mark the entire assignment as valid\n                this.expressionValidity.push({\n                    start: assign.getStart(),\n                    end: assign.getEnd(),\n                    valid: true\n                });\n            }\n        }\n        \n        const variableDecls = sourceFile.getDescendantsOfKind(SyntaxKind.VariableDeclaration);\n        for (const v of variableDecls) {\n            const init = v.getInitializer();\n            if (!init) continue;\n\n            // Check if the initializer is recognized\n            const initStart = init.getStart();\n            const initEnd = init.getEnd();\n            const recognized = this.expressionValidity.some(\n                expr => expr.valid && expr.start <= initStart && expr.end >= initEnd\n            );\n\n            // If recognized, add a range covering the entire declaration\n            if (recognized) {\n                this.expressionValidity.push({\n                    start: v.getStart(),\n                    end: v.getEnd(),\n                    valid: true\n                });\n            }\n        }\n\n        const asExpressions = sourceFile.getDescendantsOfKind(SyntaxKind.AsExpression);\n        for (const asExp of asExpressions) {\n            // This is the \"foo as SomeType\" node\n            const subExp = asExp.getExpression();\n\n            // Check if the sub-expression was recognized as valid\n            const subStart = subExp.getStart();\n            const subEnd = subExp.getEnd();\n            const recognizedSub = this.expressionValidity.some(\n                expr => expr.valid && expr.start <= subStart && expr.end >= subEnd\n            );\n\n            if (!recognizedSub) {\n                continue;\n            }\n\n            const subType = getOperatorNodeReturnType(subExp, this.context)\n                ?? this.context.TypeChecker.getTypeAtLocation(subExp);\n            // The \"as\" type from \"foo as T\"\n            const castType = this.context.TypeChecker.getTypeAtLocation(asExp.getTypeNodeOrThrow());\n\n            // If subType -> castType is valid, then mark the entire \"foo as T\" node range\n            if (subType.isAssignableTo(castType)) {\n                this.expressionValidity.push({\n                    start: asExp.getStart(),\n                    end: asExp.getEnd(),\n                    valid: true\n                });\n            }\n        }\n\n    }\n}\n\n\n\n","\n// Unity lifecycle methods\nexport const unityLifecycleMethods = [\n    { name: \"Awake\", parameters: \"\", description: \"Called when the script instance is being loaded.\", imports: [] },\n    { name: \"Start\", parameters: \"\", description: \"Called before the first frame update.\", imports: [] },\n    { name: \"OnEnable\", parameters: \"\", description: \"Called when the object becomes enabled and active.\", imports: [] },\n    { name: \"OnDisable\", parameters: \"\", description: \"Called when the object becomes disabled.\", imports: [] },\n    { name: \"OnDestroy\", parameters: \"\", description: \"Called when the MonoBehaviour will be destroyed.\", imports: [] },\n    { name: \"Update\", parameters: \"\", description: \"Called once per frame.\", imports: [] },\n    { name: \"FixedUpdate\", parameters: \"\", description: \"Called every fixed frame-rate frame.\", imports: [] },\n    { name: \"LateUpdate\", parameters: \"\", description: \"Called once per frame after Update.\", imports: [] },\n    { name: \"OnCollisionEnter\", parameters: \"collision: Collision\", description: \"Called when this collider/rigidbody has begun touching another rigidbody/collider.\", imports: [{ type: \"Collision\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionExit\", parameters: \"collision: Collision\", description: \"Called when this collider/rigidbody has stopped touching another rigidbody/collider.\", imports: [{ type: \"Collision\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionStay\", parameters: \"collision: Collision\", description: \"Called once per frame for every collider/rigidbody that is touching rigidbody/collider.\", imports: [{ type: \"Collision\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionEnter2D\", parameters: \"collision: Collision2D\", description: \"Called when this collider/rigidbody has begun touching another rigidbody/collider in 2D.\", imports: [{ type: \"Collision2D\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionExit2D\", parameters: \"collision: Collision2D\", description: \"Called when this collider/rigidbody has stopped touching another rigidbody/collider in 2D.\", imports: [{ type: \"Collision2D\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionStay2D\", parameters: \"collision: Collision2D\", description: \"Called once per frame for every collider/rigidbody that is touching rigidbody/collider in 2D.\", imports: [{ type: \"Collision2D\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerEnter\", parameters: \"other: Collider\", description: \"Called when the Collider other enters the trigger.\", imports: [{ type: \"Collider\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerExit\", parameters: \"other: Collider\", description: \"Called when the Collider other has stopped touching the trigger.\", imports: [{ type: \"Collider\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerStay\", parameters: \"other: Collider\", description: \"Called once per frame for every Collider other that is touching the trigger.\", imports: [{ type: \"Collider\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerEnter2D\", parameters: \"other: Collider2D\", description: \"Called when the Collider other enters the trigger in 2D.\", imports: [{ type: \"Collider2D\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerExit2D\", parameters: \"other: Collider2D\", description: \"Called when the Collider other has stopped touching the trigger in 2D.\", imports: [{ type: \"Collider2D\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerStay2D\", parameters: \"other: Collider2D\", description: \"Called once per frame for every Collider other that is touching the trigger in 2D.\", imports: [{ type: \"Collider2D\", module: \"UnityEngine\" }] },\n    { name: \"OnControllerColliderHit\", parameters: \"hit: ControllerColliderHit\", description: \"Called when the character controller hits a collider while performing a move.\", imports: [{ type: \"ControllerColliderHit\", module: \"UnityEngine\" }] },\n    { name: \"OnGUI\", parameters: \"\", description: \"Called for rendering and handling GUI events.\", imports: [] },\n    { name: \"OnMouseDown\", parameters: \"\", description: \"Called when the user has pressed the mouse button while over the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseDrag\", parameters: \"\", description: \"Called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.\", imports: [] },\n    { name: \"OnMouseUp\", parameters: \"\", description: \"Called when the user has released the mouse button.\", imports: [] },\n    { name: \"OnMouseEnter\", parameters: \"\", description: \"Called when the mouse enters the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseExit\", parameters: \"\", description: \"Called when the mouse is not any longer over the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseOver\", parameters: \"\", description: \"Called every frame while the mouse is over the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseUpAsButton\", parameters: \"\", description: \"Called when the user has pressed the mouse button while over the GUIElement or Collider and is still holding down the mouse.\", imports: [] },\n    { name: \"OnApplicationFocus\", parameters: \"hasFocus: boolean\", description: \"Called when the application gains or loses focus.\", imports: [] },\n    { name: \"OnApplicationPause\", parameters: \"pauseStatus: boolean\", description: \"Called when the application is paused or resumed.\", imports: [] },\n    { name: \"OnApplicationQuit\", parameters: \"\", description: \"Called when the application is about to quit.\", imports: [] },\n    { name: \"OnPreRender\", parameters: \"\", description: \"Called before a camera starts rendering the scene.\", imports: [] },\n    { name: \"OnPostRender\", parameters: \"\", description: \"Called after a camera has finished rendering the scene.\", imports: [] },\n    { name: \"OnRenderImage\", parameters: \"source: RenderTexture, destination: RenderTexture\", description: \"Called after all rendering is complete to render image.\", imports: [{ type: \"RenderTexture\", module: \"UnityEngine\" }] },\n    { name: \"OnRenderObject\", parameters: \"\", description: \"Called after camera has rendered the scene.\", imports: [] },\n    { name: \"OnWillRenderObject\", parameters: \"\", description: \"Called once for each camera if the object is visible.\", imports: [] },\n    { name: \"OnPreCull\", parameters: \"\", description: \"Called before the camera culls the scene.\", imports: [] },\n    { name: \"OnAnimatorIK\", parameters: \"layerIndex: number\", description: \"Called right after the Animator has performed IK pass.\", imports: [] },\n    { name: \"OnAnimatorMove\", parameters: \"\", description: \"Called right after the Animator updates.\", imports: [] },\n    { name: \"OnDrawGizmos\", parameters: \"\", description: \"Called when the editor draws gizmos.\", imports: [] },\n    { name: \"OnValidate\", parameters: \"\", description: \"Called when the script is loaded or a value is changed in the inspector.\", imports: [] },\n    // Experience events\n    { name: \"OnExperiencePaused\", parameters: \"\", description: \"Called when the experience is paused.\", imports: [] },\n    { name: \"OnExperienceResumed\", parameters: \"\", description: \"Called when the experience is resumed.\", imports: [] },\n    { name: \"OnExperienceQuit\", parameters: \"\", description: \"Called when the experience is quit.\", imports: [] },\n];\n\nexport const ScriptableObjectAllowedMethods = [\n    \"Awake\",\n    \"OnEnable\",\n    \"OnDisable\",\n    \"OnDestroy\",\n    \"OnValidate\",\n    \"OnApplicationFocus\",\n    \"OnApplicationPause\",\n    \"OnApplicationQuit\",\n    \"OnExperiencePaused\",\n    \"OnExperienceResumed\",\n    \"OnExperienceQuit\"\n]\n","import {\n    ArrayLiteralExpression,\n    ClassDeclaration,\n    Decorator,\n    EnumDeclaration,\n    Expression, ImportDeclarationStructure,\n    NewExpression,\n    Node, OptionalKind, Project, PropertyAccessExpression,\n    PropertyDeclaration,\n    SourceFile, StructureKind, Symbol, SymbolFlags,\n    SyntaxKind,\n    Type, TypeChecker, TypeFormatFlags, VariableStatementStructure\n} from \"ts-morph\";\nimport * as path from 'path';\nimport {TransformationContext} from \"./transformers/TransformationContext\";\n\nexport let projectRoot: string = \"\";\nexport const GeniesDeclarationFileAnnotation = \"//@Genies-UnityApiInterface\";\nexport const GeniesInstancePropName = \"__geniesInstance__\";\nexport const MonobehaviourTypeName = \"MonoBehaviour\";\nexport const ScriptableObjectTypeName = \"ScriptableObject\";\nexport const NonSerializedDecorator = \"NonSerialized\";\nexport const HideInInspectorDecorator = \"HideInInspector\";\nexport const SerializeFieldDecorator = \"SerializeField\";\nexport const HeaderDecorator = \"Header\";\nexport const SpaceDecorator = \"Space\";\nexport const TooltipDecorator = \"Tooltip\";\n\nexport const GET_ITEM_NAME = \"get_Item\";\nexport const SET_ITEM_NAME = \"set_Item\";\n\nexport const componentMethods = new Set([\n    'GetComponent',\n    'TryGetComponent',\n    'GetComponentInChildren',\n    'GetComponentsInChildren',\n    'GetComponentInParent',\n    'GetComponentsInParent',\n    'GetComponents',\n    'AddComponent'\n]);\n\nexport enum GeniesScriptUiEvents {\n    None = 0,\n    PointerClick = 1 << 0, // 1\n    PointerDown = 1 << 1, // 2\n    PointerEnter = 1 << 2, // 4\n    PointerExit = 1 << 3, // 8\n    PointerUp = 1 << 4, // 16\n    BeginDrag = 1 << 5, // 32\n    Deselect = 1 << 6, // 64\n    Drag = 1 << 7, // 128\n    Drop = 1 << 8, // 256\n    EndDrag = 1 << 9, // 512\n    InitializePotentialDrag = 1 << 10, // 1024\n    Scroll = 1 << 11, // 2048\n    Select = 1 << 12, // 4096\n    Submit = 1 << 13, // 8192\n    UpdateSelected = 1 << 14, // 16384\n    Move = 1 << 15, // 32768\n    Cancel = 1 << 16 // 65536\n}\n\nexport const AllowedUiInterfaces = new Set([\n    'UnityEngine.EventSystems.IPointerClickHandler',\n    'UnityEngine.EventSystems.IPointerDownHandler',\n    'UnityEngine.EventSystems.IPointerEnterHandler',\n    'UnityEngine.EventSystems.IPointerExitHandler',\n    'UnityEngine.EventSystems.IPointerUpHandler',\n    'UnityEngine.EventSystems.IBeginDragHandler',\n    'UnityEngine.EventSystems.IDeselectHandler',\n    'UnityEngine.EventSystems.IDragHandler',\n    'UnityEngine.EventSystems.IDropHandler',\n    'UnityEngine.EventSystems.IEndDragHandler',\n    'UnityEngine.EventSystems.IInitializePotentialDragHandler',\n    'UnityEngine.EventSystems.IScrollHandler',\n    'UnityEngine.EventSystems.ISelectHandler',\n    'UnityEngine.EventSystems.ISubmitHandler',\n    'UnityEngine.EventSystems.IUpdateSelectedHandler',\n    'UnityEngine.EventSystems.IMoveHandler',\n    'UnityEngine.EventSystems.ICancelHandler',\n]);\n\nexport const UiInterfaceToEnumMap = new Map([\n    ['UnityEngine.EventSystems.IPointerClickHandler', GeniesScriptUiEvents.PointerClick],\n    ['UnityEngine.EventSystems.IPointerDownHandler', GeniesScriptUiEvents.PointerDown],\n    ['UnityEngine.EventSystems.IPointerEnterHandler', GeniesScriptUiEvents.PointerEnter],\n    ['UnityEngine.EventSystems.IPointerExitHandler', GeniesScriptUiEvents.PointerExit],\n    ['UnityEngine.EventSystems.IPointerUpHandler', GeniesScriptUiEvents.PointerUp],\n    ['UnityEngine.EventSystems.IBeginDragHandler', GeniesScriptUiEvents.BeginDrag],\n    ['UnityEngine.EventSystems.IDeselectHandler', GeniesScriptUiEvents.Deselect],\n    ['UnityEngine.EventSystems.IDragHandler', GeniesScriptUiEvents.Drag],\n    ['UnityEngine.EventSystems.IDropHandler', GeniesScriptUiEvents.Drop],\n    ['UnityEngine.EventSystems.IEndDragHandler', GeniesScriptUiEvents.EndDrag],\n    ['UnityEngine.EventSystems.IInitializePotentialDragHandler', GeniesScriptUiEvents.InitializePotentialDrag],\n    ['UnityEngine.EventSystems.IScrollHandler', GeniesScriptUiEvents.Scroll],\n    ['UnityEngine.EventSystems.ISelectHandler', GeniesScriptUiEvents.Select],\n    ['UnityEngine.EventSystems.ISubmitHandler', GeniesScriptUiEvents.Submit],\n    ['UnityEngine.EventSystems.IUpdateSelectedHandler', GeniesScriptUiEvents.UpdateSelected],\n    ['UnityEngine.EventSystems.IMoveHandler', GeniesScriptUiEvents.Move],\n    ['UnityEngine.EventSystems.ICancelHandler', GeniesScriptUiEvents.Cancel],\n]);\n\nconst AliasToTypeName: Map<string, string> = new Map([\n        [\"float\", \"Single\"],\n        [\"int\", \"Int32\"],\n        [\"double\", \"Double\"],\n        [\"long\", \"Int64\"],\n        [\"bool\", \"Boolean\"],\n        [\"string\", \"String\"],\n        [\"number\", \"Double\"],\n        [\"short\", \"Int16\"],\n        [\"ushort\", \"UInt16\"],\n        [\"byte\", \"Byte\"],\n        [\"sbyte\", \"SByte\"],\n        [\"uint\", \"UInt32\"],\n        [\"char\", \"Char\"]\n    ]\n)\n\nconst AliasToFullTypeName: Map<string, string> = new Map([\n        [\"float\", \"System.Single\"],\n        [\"int\", \"System.Int32\"],\n        [\"double\", \"System.Double\"],\n        [\"long\", \"System.Int64\"],\n        [\"bool\", \"System.Boolean\"],\n        [\"string\", \"System.String\"],\n        [\"number\", \"System.Double\"],\n        [\"short\", \"System.Int16\"],\n        [\"ushort\", \"System.UInt16\"],\n        [\"byte\", \"System.Byte\"],\n        [\"sbyte\", \"System.SByte\"],\n        [\"uint\", \"System.UInt32\"],\n        [\"char\", \"System.Char\"]\n    ]\n)\n\nexport const NumericalAliases = new Set([\n    \"byte\",\n    \"sbyte\",\n    \"short\",\n    \"ushort\",\n    \"int\",\n    \"uint\",\n    \"float\",\n    \"double\",\n    \"number\"\n])\n\nexport enum GeniesScriptType {\n    None = 0,\n    Monobehaviour = 1,\n    ScriptableObject = 2\n}\n\nexport interface PropertyInfo {\n    Path: string;\n    Name: string;\n    TypeName: string;\n    ChildProperties: PropertyInfo[];\n    IsArray: boolean;\n    IsEnum: boolean;\n    EnumKeys: string[];\n    EnumValues: string[];\n    Decorators: GeniesDecoratorInfo[];\n    IsGeniesBehaviourRef: boolean;\n    IsGeniesScriptableObjectRef: boolean;\n    Initializers: string[];\n    ArrayElementInitializer: PropertyInfo | undefined;\n    ArrayDimension: number;\n}\n\nexport interface GeniesDecoratorInfo {\n    Type: string;\n    Args: string[];\n}\n\nexport interface FileCompileOutput {\n    FilePath: string;\n    IsSuccessful: boolean;\n    Errors?: string[];\n    BaseTypes?: string[];\n    JsSource: string;\n    IsScriptableObj: boolean;\n    IsMonobehaviour: boolean;\n    Properties: PropertyInfo[];\n    Id: string;\n    DefaultTypeName: string;\n    InheritanceChain: string[];\n    SupportedUiEvents: GeniesScriptUiEvents;\n    ReferencedSpecifiers?: string[];\n}\n\n/**\n * Sets the project root path for other utilities to consume.\n */\nexport function setProjectRoot(root: string) {\n    projectRoot = root;\n}\n\nexport function extendsMonoBehaviour(classDecl: ClassDeclaration): boolean {\n    let baseClass = classDecl.getBaseClass();\n    while (baseClass) {\n        if (baseClass.getName() === \"MonoBehaviour\") {\n            return true;\n        }\n        baseClass = baseClass.getBaseClass();\n    }\n    return false;\n}\n\nexport function extendsScriptableObject(classDecl: ClassDeclaration): boolean {\n    let baseClass = classDecl.getBaseClass();\n    while (baseClass) {\n        if (baseClass.getName() === \"ScriptableObject\") {\n            return true;\n        }\n        baseClass = baseClass.getBaseClass();\n    }\n    return false;\n}\n\nexport function removeDecorators(decorators: Decorator[], condition: (decorator: Decorator) => boolean) {\n    decorators.forEach(decorator => {\n        \n        //Wrap try/catch, there's an issue with removing decorators with trailing comments\n        //the comments seems to be considered part of the AST of the decorator\n        //this causes tsmorph to throw an error for mismatched trees.\n        //For now, we just suppress and continue (comments are safe to remove anyway)\n        try {\n            if (condition(decorator)) {\n                decorator.remove();\n            }\n        }\n        catch\n        {\n            //Ignore and continue\n        }\n    });\n}\n\n/**\n * Traverses the full prototype chain of a class, including base classes and implemented interfaces.\n * @param classDeclaration The ClassDeclaration to traverse.\n * @returns The PrototypeChain containing all base classes and interfaces.\n */\nexport function traversePrototypeChain(classDeclaration: ClassDeclaration): string[] {\n    const resultSet: Set<string> = new Set(); // To store unique type names\n\n    let currentClass: ClassDeclaration | undefined = classDeclaration;\n\n    while (currentClass) {\n        // Add the current class's full type name\n        const classTypeName = getFullTypeName(currentClass.getType());\n        if (classTypeName) {\n            resultSet.add(classTypeName);\n        }\n\n        // Process all implemented interfaces\n        const implementedInterfaces = currentClass.getImplements();\n\n        implementedInterfaces.forEach(implementClause => {\n            const ifaceType = implementClause.getType();\n\n            // Initialize queue with the current interface type\n            const queue: Type[] = [ifaceType];\n\n            while (queue.length > 0) {\n                const currentIfaceType = queue.shift();\n                if (!currentIfaceType) {\n                    continue;\n                }\n\n                const ifaceName = getFullTypeName(currentIfaceType);\n                if (!ifaceName || resultSet.has(ifaceName)) {\n                    continue; // Skip if already processed or name is invalid\n                }\n\n                resultSet.add(ifaceName);\n\n                // Enqueue extended interfaces\n                const baseTypes = currentIfaceType.getBaseTypes();\n                baseTypes.forEach(baseType => {\n                    queue.push(baseType);\n                });\n            }\n        });\n\n        // Move to the base class, if any\n        currentClass = currentClass.getBaseClass();\n    }\n\n    return Array.from(resultSet);\n}\n\n\nexport function isSignalBusType(type: Type): boolean {\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n    const name = symbol.getName();\n    return name === \"SignalBus\";\n}\n\nexport function isGeniesEventType(type: Type): boolean {\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n    const name = symbol.getName();\n\n    return name === \"GeniesEvent\";\n}\n\n\nexport function isOrInheritsFromGameObjectOrComponent(type: Type, transformationContext: TransformationContext): boolean {\n    if (!type) return false;\n\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n\n    if (['GameObject', 'Component', 'MonoBehaviour'].includes(symbol.getName())) {\n        return true;\n    }\n\n    return inheritsFrom(type, ['GameObject', 'Component', 'MonoBehaviour'], transformationContext);\n}\n\nfunction inheritsFrom(type: Type, baseNames: string[], transformationContext: TransformationContext): boolean {\n    const baseTypes = getBaseTypes(type, transformationContext);\n    for (const baseType of baseTypes) {\n        const baseTypeName = baseType.getSymbol()?.getName();\n        if (baseTypeName && baseNames.includes(baseTypeName)) {\n            return true;\n        }\n        if (inheritsFrom(baseType, baseNames, transformationContext)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction getBaseTypes(type: Type, transformationContext: TransformationContext): Type[] {\n    const baseTypes: Type[] = [];\n    const symbol = type.getSymbol();\n    if (!symbol) return baseTypes;\n\n    const declarations = symbol.getDeclarations();\n    if (!declarations) return baseTypes;\n\n    for (const declaration of declarations) {\n        if (Node.isClassDeclaration(declaration)) {\n            const heritageClauses = declaration.getHeritageClauses();\n            for (const heritageClause of heritageClauses) {\n                const types = heritageClause.getTypeNodes();\n                for (const typeNode of types) {\n                    const baseType = transformationContext.typeChecker.getTypeAtLocation(typeNode);\n                    if (baseType) {\n                        baseTypes.push(baseType);\n                    }\n                }\n            }\n        }\n    }\n    return baseTypes;\n}\n\n\nfunction extractEnumDetails(type: Type): {\n    keys: string[];\n    values: (string | number | undefined)[];\n} {\n    const symbol = type.getSymbol();\n    const declaration = symbol?.getDeclarations().find(dec => dec.getKind() === SyntaxKind.EnumDeclaration) as EnumDeclaration;\n    if (declaration) {\n        return {\n            keys: declaration.getMembers().map(member => member.getName()),\n            values: declaration.getMembers().map(member => member.getValue()) // assuming numeric or const enums\n        };\n    }\n    return {keys: [], values: []};\n}\n\nexport function sortImportsAndVars(sourceFile: SourceFile) {\n    // Get all top-level statements\n    const allStatements = sourceFile.getStatements();\n\n    // Separate import declarations, variable statements, and others.\n    const importDeclarations = allStatements.filter(stmt =>\n        stmt.getKind() === SyntaxKind.ImportDeclaration\n    );\n    const variableStatements = allStatements.filter(stmt =>\n        stmt.getKind() === SyntaxKind.VariableStatement\n    );\n    const otherStatements = allStatements.filter(stmt =>\n        stmt.getKind() !== SyntaxKind.ImportDeclaration &&\n        stmt.getKind() !== SyntaxKind.VariableStatement\n    );\n\n    // Reconstruct the source file text:\n    // 1. All sorted import declarations.\n    // 2. Then a blank line.\n    // 3. Then all sorted variable statements.\n    // 4. Then a blank line.\n    // 5. Finally, the rest of the statements.\n    const newText = [\n        ...importDeclarations.map(stmt => stmt.getText()),\n        \"\",\n        ...variableStatements.map(stmt => stmt.getText()),\n        \"\",\n        ...otherStatements.map(stmt => stmt.getText())\n    ].join(\"\\n\\n\");\n\n    // Replace the source file's text with the new text.\n    sourceFile.replaceWithText(newText);\n}\n\nfunction  getLastImportIndex(sourceFile: SourceFile): number {\n    const statements = sourceFile.getStatements();\n    let lastImportIndex = -1;\n    statements.forEach((stmt, i) => {\n        if (stmt.getKind() === SyntaxKind.ImportDeclaration) {\n            lastImportIndex = i;\n        }\n    });\n    return lastImportIndex;\n}\n\nexport function insertVariableStatements(\n    sourceFile: SourceFile,\n    varStatements: OptionalKind<VariableStatementStructure>[],\n    transformationContext: TransformationContext\n): void {\n    if (varStatements.length === 0) {\n        return;\n    }\n\n    // If we have inserted some statements before, pick up where we left off\n    let lastImportIndex: number;\n    if (transformationContext.lastGenericTypeVarIndex.has(sourceFile)) {\n        lastImportIndex = transformationContext.lastGenericTypeVarIndex.get(sourceFile)!;\n    } else {\n        lastImportIndex = getLastImportIndex(sourceFile) + 1;\n    }\n\n    // Ensure we don't exceed the number of statements\n    const statementsLength = sourceFile.getStatements().length;\n    lastImportIndex = Math.min(lastImportIndex, statementsLength);\n\n    // Insert new statements\n    sourceFile.insertVariableStatements(lastImportIndex, varStatements);\n\n    // Update index\n    transformationContext.lastGenericTypeVarIndex.set(sourceFile, lastImportIndex + varStatements.length);\n}\n\nexport function ensureTypeImported(type: Type, sourceFile: SourceFile) {\n\n    let typeName = type.getSymbol()?.getName() ?? type.getText();\n    let typeModule = \"\";\n\n    if (AliasToTypeName.has(typeName)) {\n        typeName = AliasToTypeName.get(typeName) as string;\n        typeModule = \"System\";\n    } else {\n        const scriptType = getGeniesScriptTypeFromType(type);\n        if (scriptType !== GeniesScriptType.None) {\n            switch (scriptType) {\n                case GeniesScriptType.Monobehaviour:\n                    typeName = \"MonoBehaviour\";\n                    typeModule = \"UnityEngine\";\n                    break;\n                case GeniesScriptType.ScriptableObject:\n                    typeName = \"ScriptableObject\";\n                    typeModule = \"UnityEngine\";\n                    break;\n            }\n        } else if (!getIsUnityAPIType(type)) {\n            throw new Error(\"Can't use non CSharp types\");\n        } else {\n            const csTypeName = getFullTypeName(type, true, false);\n            const lastDotIndex = csTypeName.lastIndexOf(\".\");\n            typeModule = csTypeName.substring(0, lastDotIndex);\n        }\n    }\n\n    // Check if the type's module is already imported\n    const existingImport = sourceFile.getImportDeclarations().find(importDecl => {\n        return importDecl.getModuleSpecifierValue() === typeModule;\n    });\n\n    if (!existingImport) {\n        // Add the import if it's not already imported\n        const importStructure: ImportDeclarationStructure = {\n            kind: StructureKind.ImportDeclaration,\n            moduleSpecifier: typeModule,\n            namedImports: [{name: typeName}],\n        };\n        sourceFile.addImportDeclaration(importStructure);\n    } else {\n        // If the module is imported but the type is not included, add the named import\n        const namedImports = existingImport.getNamedImports();\n        if (!namedImports.some(namedImport => namedImport.getName() === typeName)) {\n            existingImport.addNamedImport(typeName);\n        }\n    }\n}\n\nexport function getTypeNameAndEnsureImported(type: Type, sourceFile: SourceFile): string {\n\n    let typeName = type.getSymbol()?.getName() ?? type.getText();\n    let csTypeName = \"\";\n    let typeModule = \"\";\n\n    if (AliasToTypeName.has(typeName)) {\n        csTypeName = typeName = AliasToTypeName.get(typeName) as string;\n        typeModule = \"System\";\n    } else {\n        const scriptType = getGeniesScriptTypeFromType(type);\n        if (scriptType !== GeniesScriptType.None) {\n            switch (scriptType) {\n                case GeniesScriptType.Monobehaviour:\n                    typeName = \"MonoBehaviour\";\n                    typeModule = \"UnityEngine\";\n                    break;\n                case GeniesScriptType.ScriptableObject:\n                    typeName = \"ScriptableObject\";\n                    typeModule = \"UnityEngine\";\n                    break;\n            }\n        } else if (!getIsUnityAPIType(type)) {\n            throw new Error(\"Can't use non CSharp types\");\n        } else {\n            csTypeName = getFullTypeName(type, true, false);\n            const lastDotIndex = csTypeName.lastIndexOf(\".\");\n            typeModule = csTypeName.substring(0, lastDotIndex);\n        }\n    }\n\n    // Check if the type's module is already imported\n    const existingImport = sourceFile.getImportDeclarations().find(importDecl => {\n        return importDecl.getModuleSpecifierValue() === typeModule;\n    });\n\n    if (!existingImport) {\n        // Add the import if it's not already imported\n        const importStructure: ImportDeclarationStructure = {\n            kind: StructureKind.ImportDeclaration,\n            moduleSpecifier: typeModule,\n            namedImports: [{name: typeName}],\n        };\n        sourceFile.addImportDeclaration(importStructure);\n    } else {\n        // If the module is imported but the type is not included, add the named import\n        const namedImports = existingImport.getNamedImports();\n        if (!namedImports.some(namedImport => namedImport.getName() === typeName)) {\n            existingImport.addNamedImport(typeName);\n        }\n    }\n\n    // Return the $typeof conversion string\n    return `$typeof(\"${csTypeName}\")`;\n}\n\nexport function getFullTypeName(type: Type, forCsharp: boolean = true, includeArguments: boolean = true): string {\n    let text = \"\";\n\n    const aliasSymbol = type.getAliasSymbol();\n    if (aliasSymbol) {\n        text = aliasSymbol.getName();\n    } else {\n        text = type.getText();\n    }\n\n    if (AliasToFullTypeName.has(text)) {\n        return AliasToFullTypeName.get(text) as string;\n    }\n\n    const symbol = type.getSymbol();\n    if (!symbol) {\n        return text; // Return the simple type text if no symbol is available\n    }\n\n    if (!getIsUnityAPIType(type)) {\n        const declarations = symbol.getDeclarations();\n        let isExported = false;\n\n        declarations.forEach(decl => {\n            if (Node.isInterfaceDeclaration(decl) || Node.isClassDeclaration(decl)) {\n                isExported = decl.isExported();\n            }\n        });\n\n        if (!isExported && declarations.length > 0) {\n            const sourceFile = declarations[0].getSourceFile();\n            const sourceFilePath = sourceFile.getFilePath();\n            const relativePath = convertToAliasPath(projectRoot, sourceFilePath);\n            const parsedPath = path.parse(relativePath);\n            const filePathWithoutExt = path.join(parsedPath.dir, parsedPath.name);\n\n            text = `${filePathWithoutExt}.${symbol.getFullyQualifiedName().replace(/['\"]/g, \"\")}`;\n        } else {\n            text = symbol.getFullyQualifiedName().replace(/['\"]/g, \"\");\n        }\n\n        const parsed = path.parse(text);\n        // If 'dir' isnt empty, it suggests that text includes some slash-like separator\n        const isPath = parsed.dir !== \"\" || parsed.root !== \"\";\n        if (isPath) {\n            let aliasPath = convertToGeniesAliasPath(text);\n\n            if (aliasPath != null) {\n                text = aliasPath;\n            }\n        }\n\n    } else {\n        text = symbol.getFullyQualifiedName().replace(/['\"]/g, \"\");\n    }\n\n    const regex = /\\$\\d+$/;\n    if (forCsharp && regex.test(text)) {\n\n        text = text.replace(regex, \"\");\n\n        if (includeArguments) {\n            const typeArguments = type.getTypeArguments();\n            if (typeArguments.length > 0) {\n                text += '<';\n                typeArguments.forEach((arg, index) => {\n                    let argText = getFullTypeName(arg);\n                    text += argText;\n                    if (index < typeArguments.length - 1) {\n                        text += ', ';\n                    }\n                });\n                text += '>';\n            }\n        }\n    }\n\n    return text;\n}\n\nexport function extractProperties(cls: ClassDeclaration, basePath: string = '', typeArgumentMap: Map<string, Type> = new Map()): PropertyInfo[] {\n    const properties: PropertyInfo[] = [];\n\n    cls.getProperties().forEach(prop => {\n        const visibility = prop.getScope();\n        const decorators = extractDecorators(prop);\n\n        // Skip static or readonly properties\n        if (prop.isStatic() || prop.isReadonly()) {\n            return;\n        }\n\n        if (visibility === 'private' && !decorators.some(d => d.Type === SerializeFieldDecorator)) {\n            return;\n        }\n\n        if (visibility === 'public' && decorators.some(d => d.Type === NonSerializedDecorator)) {\n            return;\n        }\n\n        const type = resolveGenericType(prop.getType(), typeArgumentMap);\n        const isArray = type.isArray();\n\n        const resolvedType = resolveArrayElementType(type, typeArgumentMap);\n        const typeName = getFullTypeName(resolvedType);\n        const propName = prop.getName();\n        let fullPath = basePath ? `${basePath}.${propName}` : propName;\n\n        function getInitializer(expression: Expression): string {\n            if (expression.getKind() === SyntaxKind.NewExpression) {\n                const newExpression = expression as NewExpression;\n                const type = newExpression.getType();\n                const fullTypeName = getFullTypeName(type);\n\n                // Extract the arguments of the new expression\n                const args = newExpression.getArguments().map(arg => arg.getText()).join(\", \");\n                return `new ${fullTypeName}(${args});`;\n            } else if (expression.getKind() === SyntaxKind.PropertyAccessExpression) {\n                // Handle something like \"Vector3.forward\"\n                const pae = expression as PropertyAccessExpression;\n\n                // The left side should be something like \"Vector3\"\n                const leftExpr = pae.getExpression();\n                const leftType = leftExpr.getType();\n\n                const leftFullTypeName = getFullTypeName(leftType);\n\n                // The right side (the actual property), e.g. \"forward\"\n                const memberName = pae.getName();\n\n                // Return e.g. \"UnityEngine.Vector3.forward\"\n                return `${leftFullTypeName}.${memberName}`;\n\n            } else {\n                // Fallback: just return the raw text\n                return expression.getText();\n            }\n        }\n\n        const initializerExpressions: string[] = [];\n        if (prop.hasInitializer()) {\n            const initializer = prop.getInitializer();\n            if (initializer) {\n                if (initializer.getKind() === SyntaxKind.ArrayLiteralExpression) {\n                    const arrayLiteral = initializer as ArrayLiteralExpression;\n                    for (let i = 0; i < arrayLiteral.getElements().length; i++) {\n                        const element = arrayLiteral.getElements()[i];\n                        initializerExpressions.push(getInitializer(element));\n                    }\n                } else {\n                    initializerExpressions.push(getInitializer(initializer));\n                }\n            }\n        }\n\n        const propertyInfo: PropertyInfo = {\n            Path: fullPath,\n            Name: propName,\n            TypeName: typeName,\n            ChildProperties: [],\n            IsArray: isArray,\n            IsEnum: false,\n            EnumKeys: [],\n            EnumValues: [],\n            Decorators: extractDecorators(prop),\n            IsGeniesBehaviourRef: false,\n            IsGeniesScriptableObjectRef: false,\n            Initializers: initializerExpressions,\n            ArrayElementInitializer: undefined,\n            ArrayDimension: -1,\n        };\n\n        if (isArray) {\n            let dimension = 1;\n            propertyInfo.ArrayElementInitializer = getArrayElementInitializer(type, typeName, propName, fullPath, dimension, typeArgumentMap);\n            propertyInfo.ArrayDimension = dimension;\n            properties.push(propertyInfo);\n            return;\n        }\n\n        fillExtraPropertyInfo(resolvedType, propertyInfo, typeArgumentMap);\n        properties.push(propertyInfo);\n    });\n\n    return properties;\n}\n\nfunction fillExtraPropertyInfo(resolvedType: Type, propertyInfo: PropertyInfo, typeArgumentMap: Map<string, Type>) {\n    const isEnum = resolvedType.isEnum();\n    const symbol = resolvedType.getSymbol() || resolvedType.getAliasSymbol();\n\n    if (!symbol) {\n        return;\n    }\n\n    const declarations = symbol.getDeclarations();\n    const declaration = declarations[0];\n    const isUnityType = getIsUnityAPIDeclaration(declaration);\n    const geniesScriptType = getGeniesScriptTypeFromNode(declaration, isUnityType);\n\n    propertyInfo.IsGeniesBehaviourRef = geniesScriptType == GeniesScriptType.Monobehaviour;\n    propertyInfo.IsGeniesScriptableObjectRef = geniesScriptType == GeniesScriptType.ScriptableObject;\n\n    if (isUnityType || geniesScriptType !== GeniesScriptType.None) {\n        return;\n    }\n\n    if (isEnum) {\n        fillEnumInfo(propertyInfo, resolvedType);\n    }\n\n    if (symbol.getDeclarations().some(declaration => Node.isClassDeclaration(declaration))) {\n        const classDecl = symbol.getDeclarations().find(Node.isClassDeclaration) as ClassDeclaration;\n        const typeParams = classDecl.getTypeParameters();\n        const typeArgs = resolvedType.getTypeArguments();\n        const newTypeArgumentMap = new Map(typeArgumentMap);\n\n        typeParams.forEach((param, index) => {\n            const paramName = param.getName();\n            const uniqueParamName = `${paramName}_${classDecl.getName()}`; // Ensure uniqueness by appending the class name\n            newTypeArgumentMap.set(uniqueParamName, typeArgs[index]);\n        });\n\n        //Collect properties\n        const childProperties: PropertyInfo[] = [];\n        let baseClass = classDecl;\n        while (baseClass) {\n            const baseClassName = baseClass.getName();\n\n            childProperties.unshift(...extractProperties(baseClass, propertyInfo.Path, newTypeArgumentMap));\n\n            let newBase = baseClass.getBaseClass();\n            if (newBase !== undefined) {\n                baseClass = newBase;\n            } else {\n                break;\n            }\n        }\n\n        propertyInfo.ChildProperties = childProperties;\n    }\n}\n\nfunction fillEnumInfo(propertyInfo: PropertyInfo, resolvedType: Type) {\n    const {keys, values} = extractEnumDetails(resolvedType);\n    propertyInfo.EnumKeys = keys;\n    propertyInfo.EnumValues = values.map(value => value === undefined ? \"\" : value.toString());\n    propertyInfo.IsEnum = true;\n}\n\nfunction getArrayElementInitializer(type: Type, underlyingTypeName: string, propName: string, propPath: string, dimension: number, typeArgumentMap: Map<string, Type>): PropertyInfo {\n    let resolvedType = type.isArray() ? type.getArrayElementType()! : type;\n\n    // Ensure proper resolution of generic type arguments and array elements\n    if (!resolvedType.isArray()) {\n        resolvedType = resolveArrayElementType(resolvedType, typeArgumentMap);\n    }\n\n    let currentDimension = dimension;\n\n    const propertyInfo: PropertyInfo = {\n        Path: propPath + \"_D\" + dimension,\n        Name: propName,\n        TypeName: underlyingTypeName,\n        ArrayDimension: dimension,\n        ChildProperties: [],\n        IsArray: resolvedType.isArray(),\n        IsEnum: resolvedType.isEnum(),\n        EnumKeys: [],\n        EnumValues: [],\n        Decorators: [],\n        IsGeniesBehaviourRef: false,\n        IsGeniesScriptableObjectRef: false,\n        Initializers: [],\n        ArrayElementInitializer: undefined\n    };\n\n    if (!resolvedType.isArray()) {\n        fillExtraPropertyInfo(resolvedType, propertyInfo, typeArgumentMap);\n    } else {\n        propertyInfo.ArrayElementInitializer = getArrayElementInitializer(resolvedType, underlyingTypeName, propName, propPath, ++currentDimension, typeArgumentMap);\n    }\n\n    return propertyInfo;\n}\n\nfunction resolveGenericType(type: Type, typeArgumentMap: Map<string, Type>): Type {\n    let resolvedType = type;\n\n    if (resolvedType.isTypeParameter()) {\n        const typeName = resolvedType.getSymbol()?.getName();\n        const parentDecl = resolvedType.getSymbol()?.getDeclarations()[0].getParent();\n        const declaringClassName = parentDecl && Node.isClassDeclaration(parentDecl) ? parentDecl.getName() : '';\n        const uniqueTypeName = `${typeName}_${declaringClassName}`; // Ensure uniqueness by appending the class name\n        if (uniqueTypeName && typeArgumentMap.has(uniqueTypeName)) {\n            resolvedType = typeArgumentMap.get(uniqueTypeName)!;\n        }\n    }\n\n    return resolvedType;\n}\n\nfunction resolveArrayElementType(type: Type, typeArgumentMap: Map<string, Type>): Type {\n    let resolvedType = type;\n\n    while (resolvedType?.isArray()) {\n        resolvedType = resolvedType.getArrayElementType()!;\n    }\n\n    resolvedType = resolveGenericType(resolvedType, typeArgumentMap);\n\n    return resolvedType;\n}\n\nfunction getIsUnityAPISourceFile(sourceFile: SourceFile) {\n    if (!sourceFile) {\n        return false;\n    }\n\n    const firstNode = sourceFile.getFirstChild();\n\n    if (!firstNode) {\n        console.log(\"No nodes found in the file.\");\n        return false;\n    }\n\n    const leadingComments = firstNode.getLeadingCommentRanges();\n    return leadingComments.length > 0 && leadingComments[0].getText() === GeniesDeclarationFileAnnotation;\n}\n\nexport function getIsValidUnityGenericTypeArg(argType: Type) {\n    let text = \"\";\n\n    const aliasSymbol = argType.getAliasSymbol();\n    if (aliasSymbol) {\n        text = aliasSymbol.getName();\n    } else {\n        text = argType.getText();\n    }\n\n    if ([\"float\", \"int\", \"double\", \"long\", \"bool\", \"string\", \"number\"].includes(text)) {\n        return true;\n    }\n\n    const scriptType = getGeniesScriptTypeFromType(argType);\n    if (scriptType !== GeniesScriptType.None) {\n        return true;\n    }\n\n    return getIsUnityAPIType(argType);\n}\n\nexport function getIsUnityAPIType(type: Type) {\n    // Try to get the primary symbol\n    let symbol = type.getSymbol();\n\n    \n    // If it's missing, try the alias symbol (for types like aliases, etc.)\n    if (!symbol) {\n        let s = type.getApparentType().getSymbol();\n        \n        if(s)\n        {\n            console.log(s.getName())\n        }\n        \n        return;\n    }\n\n    const declarations = symbol.getDeclarations();\n    if (!declarations || declarations.length === 0) {\n        return;\n    }\n\n    const sourceFile = declarations[0].getSourceFile();\n    return getIsUnityAPISourceFile(sourceFile);\n}\n\nexport function getTypeByName(typeName: string, typeChecker: TypeChecker): Type | undefined {\n    // Resolve the symbol for the type name in the global scope\n    const symbol = typeChecker.resolveName(typeName, undefined, SymbolFlags.All, false);\n\n    if (!symbol) {\n        console.log(`Global type '${typeName}' not found.`);\n        return undefined;\n    }\n\n    // Get the type from the symbol\n    const type = typeChecker.getDeclaredTypeOfSymbol(symbol);\n\n    return type;\n}\n\nexport function cleanTypeText(typeText: string): string {\n    // Remove branding and extra spaces\n    return typeText.replace(/&\\s*\\{[^}]*\\}/, '').trim();\n}\n\nexport function isAssignmentToSymbol(node: Node, symbol: Symbol): boolean {\n    if (Node.isPropertyAccessExpression(node)) {\n        const expression = node.getExpression();\n        if (Node.isThisExpression(expression)) {\n            const leftSymbol = node.getNameNode().getSymbol();\n            return leftSymbol === symbol;\n        }\n    } else if (Node.isIdentifier(node)) {\n        const leftSymbol = node.getSymbol();\n        return leftSymbol === symbol;\n    }\n    return false;\n}\n\nexport function getIsUnityAPIDeclaration(declaration: Node): boolean {\n    const sourceFile = declaration.getSourceFile();\n    return getIsUnityAPISourceFile(sourceFile);\n}\n\nfunction getGeniesScriptTypeFromNode(declaration: Node, isUnityType: boolean): GeniesScriptType {\n    if (declaration.getKind() !== SyntaxKind.ClassDeclaration || isUnityType) {\n        return GeniesScriptType.None;\n    }\n\n    const cls = declaration as ClassDeclaration;\n    const isMonobehaviour = extendsMonoBehaviour(cls);\n    const isScriptableObject = extendsScriptableObject(cls);\n\n    if (isMonobehaviour) {\n        return GeniesScriptType.Monobehaviour;\n    }\n\n    if (isScriptableObject) {\n        return GeniesScriptType.ScriptableObject;\n    }\n\n    return GeniesScriptType.None;\n}\n\nexport function getGeniesScriptTypeFromType(type: Type): GeniesScriptType {\n    const symbol = type.getSymbol();\n\n    if (!symbol) {\n        return GeniesScriptType.None;\n    }\n\n    const declarations = symbol.getDeclarations();\n    if (declarations.length === 0) {\n        return GeniesScriptType.None;\n    }\n\n    const declaration = declarations[0];\n    const isUnityType = getIsUnityAPIDeclaration(declaration)\n    return getGeniesScriptTypeFromNode(declaration, isUnityType);\n}\n\nexport function isGeniesScriptType(type: Type): boolean {\n    let gType = getGeniesScriptTypeFromType(type);\n    return gType === GeniesScriptType.Monobehaviour || gType === GeniesScriptType.ScriptableObject;\n}\n\n/**\n * Converts an absolute path to an alias path based on predefined rules.\n *\n * @param absolutePath - The absolute path to convert.\n * @returns The aliased path or null if it doesn't match any alias rules.\n */\nexport function convertToGeniesAliasPath(absolutePath: string): string | null {\n    // Normalize the path to use forward slashes\n    const normalizedPath = normalizePath(absolutePath);\n\n    // Check if the path includes '/Assets/'\n    const assetsPrefix = '/Assets/';\n    const assetsIndex = normalizedPath.indexOf(assetsPrefix);\n    if (assetsIndex !== -1) {\n        const relativePath = normalizedPath.substring(assetsIndex + assetsPrefix.length);\n        return `@assets/${relativePath}`;\n    }\n\n    // Check if the path includes '/com.genies.<package>/'\n    const comGeniesRegex = /\\/(com\\.genies\\.[^\\/]+)\\//;\n    const comGeniesMatch = normalizedPath.match(comGeniesRegex);\n    if (comGeniesMatch) {\n        const packageName = comGeniesMatch[1]; // e.g., com.genies.experience.sdk\n        const pathAfterPackage = normalizedPath.substring(comGeniesMatch.index! + comGeniesMatch[0].length);\n        return `@${packageName}/${pathAfterPackage}`;\n    }\n\n    // If no alias rule matches, return null\n    return null;\n}\n\n/**\n * Normalizes a file path to use forward slashes.\n *\n * @param p - The path to normalize.\n * @returns The normalized path.\n */\nfunction normalizePath(p: string): string {\n    return p.split(path.sep).join('/');\n}\n\n/**\n * Converts a relative import path to an alias path if applicable.\n *\n * @param root\n * @param relativePath - The relative import path.\n * @returns The aliased path or the original relative path if no alias applies.\n */\nexport function convertToAliasPath(root: string, relativePath: string): string {\n\n    const absolutePath = path.resolve(root, relativePath);\n    const aliasPath = convertToGeniesAliasPath(absolutePath);\n\n    if (aliasPath) {\n        return aliasPath;\n    }\n\n    // If no alias applies, return the normalized relative path\n    return relativePath;\n}\n\n/**\n * Updates import declarations in a source file to use alias paths for Assets/ and com.genies.* packages.\n *\n * @param sourceFile - The TypeScript source file to process.\n */\nexport function updateImportsToAliasPaths(sourceFile: SourceFile) {\n    const filePath = sourceFile.getDirectoryPath() as string;\n\n    sourceFile.getImportDeclarations().forEach(importDeclaration => {\n        const moduleSpecifier = importDeclaration.getModuleSpecifierValue();\n\n        // Check if the import path is relative\n        if (moduleSpecifier.startsWith('./') || moduleSpecifier.startsWith('../')) {\n            // Convert the relative path to an alias path\n            const aliasPath = convertToAliasPath(filePath, moduleSpecifier);\n\n            // Update the module specifier if it's been converted to an alias\n            if (aliasPath.startsWith('@assets/') || aliasPath.startsWith('@com.genies')) {\n                importDeclaration.setModuleSpecifier(aliasPath);\n            }\n        }\n    });\n}\n\nfunction extractDecorators(prop: PropertyDeclaration): GeniesDecoratorInfo[] {\n    return prop.getDecorators().map(d => {\n        const decoratorInfo: GeniesDecoratorInfo = {\n            Type: d.getName(),\n            Args: d.getArguments().map(a => a.getText())\n        };\n        return decoratorInfo;\n    });\n}\n","import {\n    CallExpression, MethodDeclaration,\n    Node,\n    PropertyDeclaration,\n    Symbol,\n    SyntaxKind, ts,\n    Type,\n    TypeChecker,\n    VariableDeclaration\n} from \"ts-morph\";\nimport {cleanTypeText, getTypeByName, isAssignmentToSymbol, NumericalAliases} from \"./CompilerUtils\";\nimport CallLikeExpression = ts.CallLikeExpression;\n\ninterface NumericLiteralInfo {\n    value: number;\n    hasDecimal: boolean;\n}\n\nexport function inferPossibleTypes(arg: Node, typeChecker: TypeChecker): Type[] {\n    const types: Type[] = [];\n    const argType = typeChecker.getTypeAtLocation(arg);\n\n    let inferredTypeNames: string[] = [];\n\n    const brandedType = getBrandedTypes(argType, typeChecker);\n    if (brandedType != null) {\n        types.push(brandedType);\n    } else {\n        // Attempt to get the numeric literal info\n        const numericInfo = getNumericValue(arg);\n        if (numericInfo !== undefined) {\n            inferredTypeNames = inferTypesFromNumericInfo(numericInfo);\n        } else {\n            // Use the argument's type\n            if (isNumberType(argType)) {\n                // Include all number types\n                inferredTypeNames = ['byte', 'sbyte', 'short', 'ushort', 'int', 'uint', 'float', 'double'];\n            } else {\n                types.push(argType);\n                return types;\n            }\n        }\n    }\n\n\n    // Convert type names to Type objects\n    for (const typeName of inferredTypeNames) {\n        const type = getTypeByName(typeName, typeChecker);\n        if (type) {\n            types.push(type);\n        }\n    }\n\n    return types;\n}\n\n\nexport function selectBestOverload(\n    overloads: MethodDeclaration[],\n    callExpression: CallExpression,\n    typeChecker: TypeChecker\n): MethodDeclaration | undefined {\n    \n    if(!overloads || overloads.length <= 0) {\n        return undefined;\n    }\n    \n    //If only 1 overload, return it.\n    if(overloads.length == 1) {\n        return overloads[0];\n    }\n    \n    const callArgs = callExpression.getArguments();\n    \n    if(!callArgs || callArgs.length <= 0) {\n        const noArgOverload = overloads.find(overload => overload.getParameters().length === 0);\n        if (noArgOverload) {\n            return noArgOverload;\n        }\n        \n        return undefined;\n    }\n    \n    // Infer possible types for each argument\n    const argumentTypesList = callExpression.getArguments().map(arg =>\n        inferPossibleTypes(arg, typeChecker)\n    );\n\n    let bestOverload: MethodDeclaration | undefined;\n    let highestScore = -1;\n\n    for (const overload of overloads) {\n        const score = scoreOverload(overload, argumentTypesList, typeChecker);\n        if (score > highestScore) {\n            highestScore = score;\n            bestOverload = overload;\n        }\n    }\n\n    return bestOverload;\n}\n\nfunction scoreOverload(\n    overload: MethodDeclaration,\n    argumentTypesList: Type[][],\n    typeChecker: TypeChecker): number {\n    const parameters = overload.getParameters();\n    \n    //Assume that its not the correct overload, this also accounts for the chance that params are optional.\n    if (parameters.length < argumentTypesList.length) return -1;\n    \n    //If exact match of params to args we start the score at 1\n    let score = parameters.length == argumentTypesList.length ? 1 : 0;\n    for (let i = 0; i < parameters.length; i++) {\n        const paramType = typeChecker.getTypeAtLocation(parameters[i]);\n        const argTypes = argumentTypesList[i];\n        \n        if(!argTypes || argTypes.length <= 0) {\n            return -1;\n        }\n\n        const argScore = scoreParameter(paramType, argTypes, typeChecker);\n        if (argScore < 0) {\n            return -1;\n        }\n        score += argScore;\n    }\n\n    return score;\n}\n\nfunction scoreParameter(\n    paramType: Type,\n    possibleArgTypes: Type[],\n    typeChecker: TypeChecker\n): number {\n    let bestScore = -1;\n\n    // 1) If it's a type parameter, see if we can unify with the constraint\n    if (paramType.isTypeParameter()) {\n        const constraint = paramType.getConstraint();\n        if (!constraint) {\n            if (possibleArgTypes.length > 0) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n\n        for (const argType of possibleArgTypes) {\n            if (typesAreEqual(argType, constraint)) {\n                bestScore = Math.max(bestScore, 2);\n            } else if (typeChecker.isTypeAssignableTo(argType, constraint)) {\n                bestScore = Math.max(bestScore, 1);\n            }\n        }\n        return bestScore;\n    }\n\n    // 2) If paramType is a recognized numeric type\n    if (isValidNumericalType(paramType)) {\n        // numeric param => exact match => score 2, otherwise castable => 1\n        for (const argType of possibleArgTypes) {\n            if (typesAreEqual(argType, paramType)) {\n                bestScore = Math.max(bestScore, 2);\n            } else if (isNumericCastable(argType, paramType)) {\n                bestScore = Math.max(bestScore, 1);\n            }\n        }\n        return bestScore;\n    }\n\n    // 3) Non-numeric, non-type-parameter exact match or isTypeAssignableTo.\n    for (const argType of possibleArgTypes) {\n        if (typesAreEqual(argType, paramType)) {\n            bestScore = Math.max(bestScore, 2);\n        } else if (typeChecker.isTypeAssignableTo(argType, paramType)) {\n            bestScore = Math.max(bestScore, 1);\n        }\n    }\n\n    return bestScore;\n}\n\nfunction isValidNumericalType(type: Type): boolean {\n    const typeText = cleanTypeText(type.getText());\n\n    return NumericalAliases.has(typeText);\n}\n\nexport function isNumericCastable(fromType: Type, toType: Type): boolean {\n    const castabilityMap: { [key: string]: string[] } = {\n        byte: ['short', 'ushort', 'int', 'uint', 'float', 'double', 'number'],\n        sbyte: ['short', 'int', 'float', 'double', 'number'],\n        short: ['int', 'float', 'double', 'number'],\n        ushort: ['int', 'uint', 'float', 'double', 'number'],\n        int: ['float', 'double', 'number'],\n        uint: ['float', 'double', 'number'],\n        float: ['double', 'number'],\n        double: ['number'],\n        number: ['byte', 'sbyte', 'short', 'ushort', 'int', 'uint', 'float', 'double'],\n    };\n\n    const fromTypeName = cleanTypeText(fromType.getText());\n    const toTypeName = cleanTypeText(toType.getText());\n\n    return castabilityMap[fromTypeName]?.includes(toTypeName) ?? false;\n}\n\nexport function typesAreEqual(type1: Type, type2: Type): boolean {\n    const type1Text = cleanTypeText(type1.getText());\n    const type2Text = cleanTypeText(type2.getText());\n    return type1Text === type2Text;\n}\n\nexport function getNumericValue(arg: Node): NumericLiteralInfo | undefined {\n    // Handle numeric literals and negative numbers\n    const numericLiteralInfo = getNumericLiteralInfo(arg);\n    if (numericLiteralInfo !== undefined) {\n        return numericLiteralInfo;\n    }\n\n    // Handle variables and properties by performing flow analysis\n    if (Node.isIdentifier(arg) || Node.isPropertyAccessExpression(arg)) {\n        const symbol = arg.getSymbol();\n        if (symbol) {\n            const declarations = symbol.getDeclarations();\n            if (declarations && declarations.length > 0) {\n                const decl = declarations[0];\n                if (Node.isVariableDeclaration(decl) || Node.isPropertyDeclaration(decl)) {\n                    // Perform flow analysis to get the variable's value at the point of usage\n                    const valueInfo = performFlowAnalysis(symbol, decl, arg);\n                    if (valueInfo) {\n                        return valueInfo;\n                    }\n                }\n            }\n        }\n    }\n\n    return undefined;\n}\n\nfunction isNumberType(type: Type): boolean {\n    const typeText = cleanTypeText(type.getText());\n    return typeText === 'number';\n}\n\nfunction getNumericLiteralInfo(arg: Node): NumericLiteralInfo | undefined {\n    if (Node.isNumericLiteral(arg)) {\n        const text = arg.getText();\n        const value = Number(text);\n        const hasDecimal = text.includes('.');\n        return {value, hasDecimal};\n    } else if (Node.isPrefixUnaryExpression(arg) && arg.getOperatorToken() === SyntaxKind.MinusToken) {\n        const operand = arg.getOperand();\n        if (Node.isNumericLiteral(operand)) {\n            const text = operand.getText();\n            const value = -Number(text);\n            const hasDecimal = text.includes('.');\n            return {value, hasDecimal};\n        }\n    }\n    return undefined;\n}\n\nfunction inferTypesFromNumericInfo(info: NumericLiteralInfo): string[] {\n    const {value, hasDecimal} = info;\n    const types = new Set<string>();\n\n    if (!hasDecimal) {\n        // Original literal did not have a decimal point; treat as integer\n        if (value >= -2147483648 && value <= 2147483647) {\n            types.add('int');\n        }\n        if (value >= -32768 && value <= 32767) {\n            types.add('short');\n        }\n        if (value >= -128 && value <= 127) {\n            types.add('sbyte');\n        }\n        if (value >= 0 && value <= 255) {\n            types.add('byte');\n        }\n        if (value >= 0 && value <= 65535) {\n            types.add('ushort');\n        }\n        if (value >= 0 && value <= 4294967295) {\n            types.add('uint');\n        }\n    } else {\n        // Original literal had a decimal point; treat as float\n        types.add('float');\n        types.add('double');\n    }\n\n    return Array.from(types);\n}\n\nfunction getBrandedTypes(type: Type, typeChecker: TypeChecker): Type | null {\n\n    const typeText = type.getText();\n\n    if (NumericalAliases.has(typeText)) {\n        const brandedType = getTypeByName(typeText, typeChecker);\n        if (brandedType) {\n            return brandedType;\n        }\n    }\n\n    // Check for branded types by looking for '& { __brand?: undefined }'\n    const match = typeText.match(/number\\s*&\\s*\\{\\s*__([a-zA-Z]+)Brand\\?:\\s*undefined\\s*\\}/);\n    if (match) {\n        const brand = match[1];\n        const typeName = brand;\n\n        const brandedType = getTypeByName(typeName, typeChecker);\n        if (brandedType) {\n            return brandedType;\n        }\n    }\n\n    return null;\n}\n\n\nfunction performFlowAnalysis(\n    symbol: Symbol,\n    declaration: VariableDeclaration | PropertyDeclaration,\n    usageNode: Node\n): NumericLiteralInfo | undefined {\n    let currentValueInfo: NumericLiteralInfo | undefined = undefined;\n\n    // First, check if the variable/property has an initializer\n    const initializer = declaration.getInitializer();\n    if (initializer) {\n        const initValueInfo = getNumericValueFromExpression(initializer, symbol, declaration, usageNode);\n        if (initValueInfo) {\n            currentValueInfo = initValueInfo;\n        }\n    }\n\n    // Find the method where the usage occurs\n    const methodDeclaration = usageNode.getFirstAncestorByKind(SyntaxKind.MethodDeclaration);\n    if (!methodDeclaration) {\n        return currentValueInfo; // Cannot proceed without method context\n    }\n\n    const statements = methodDeclaration.getStatements() || [];\n\n    let tracking = true; // Since we only care about the method scope, we can start tracking immediately\n\n    const usageStart = usageNode.getStart();\n\n    for (const stmt of statements) {\n        if (stmt.getStart() > usageStart) {\n            // Reached the usage point\n            break;\n        }\n\n        if (tracking) {\n            // Check for assignments to the variable/property\n            const assignments = stmt.getDescendants().filter(node =>\n                Node.isBinaryExpression(node) ||\n                Node.isPrefixUnaryExpression(node) ||\n                Node.isPostfixUnaryExpression(node)\n            );\n\n            for (const assignment of assignments) {\n                if (Node.isBinaryExpression(assignment)) {\n                    const operatorKind = assignment.getOperatorToken().getKind();\n                    const left = assignment.getLeft();\n                    const right = assignment.getRight();\n\n                    if (isAssignmentToSymbol(left, symbol)) {\n                        if (operatorKind === SyntaxKind.EqualsToken) {\n                            // Simple assignment\n                            const valueInfo = getNumericValueFromExpression(\n                                right,\n                                symbol,\n                                declaration,\n                                usageNode,\n                                currentValueInfo\n                            );\n                            if (valueInfo) {\n                                currentValueInfo = valueInfo;\n                            } else {\n                                currentValueInfo = undefined;\n                            }\n                        } else if (\n                            [\n                                SyntaxKind.PlusEqualsToken,\n                                SyntaxKind.MinusEqualsToken,\n                                SyntaxKind.AsteriskEqualsToken,\n                                SyntaxKind.SlashEqualsToken,\n                                SyntaxKind.PercentEqualsToken,\n                            ].includes(operatorKind)\n                        ) {\n                            // Compound assignment\n                            const valueInfo = getNumericValueFromExpression(\n                                right,\n                                symbol,\n                                declaration,\n                                usageNode,\n                                currentValueInfo\n                            );\n                            if (valueInfo && currentValueInfo) {\n                                const resultValueInfo = evaluateCompoundAssignment(\n                                    operatorKind,\n                                    currentValueInfo,\n                                    valueInfo\n                                );\n                                if (resultValueInfo) {\n                                    currentValueInfo = resultValueInfo;\n                                } else {\n                                    currentValueInfo = undefined;\n                                }\n                            } else {\n                                currentValueInfo = undefined;\n                            }\n                        }\n                    }\n                } else if (Node.isPrefixUnaryExpression(assignment) || Node.isPostfixUnaryExpression(assignment)) {\n                    const operatorKind = assignment.getOperatorToken();\n                    const operand = assignment.getOperand();\n\n                    if (isAssignmentToSymbol(operand, symbol)) {\n                        // Increment or decrement\n                        if (currentValueInfo) {\n                            let delta = operatorKind === SyntaxKind.PlusPlusToken ? 1 : -1;\n                            currentValueInfo = {\n                                value: currentValueInfo.value + delta,\n                                hasDecimal: currentValueInfo.hasDecimal,\n                            };\n                        } else {\n                            currentValueInfo = undefined;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return currentValueInfo;\n}\n\n\nfunction getNumericValueFromExpression(\n    expr: Node,\n    symbol: Symbol,\n    declaration: VariableDeclaration | PropertyDeclaration,\n    usageNode: Node,\n    currentValueInfo?: NumericLiteralInfo\n): NumericLiteralInfo | undefined {\n    if (Node.isNumericLiteral(expr)) {\n        return getNumericLiteralInfo(expr);\n    } else if (Node.isIdentifier(expr) || Node.isPropertyAccessExpression(expr)) {\n        if (isAssignmentToSymbol(expr, symbol)) {\n            // Use the current value of the variable/property\n            return currentValueInfo;\n        } else {\n            // Retrieve the value of another variable or property\n            const exprSymbol = expr.getSymbol();\n            if (exprSymbol) {\n                const declarations = exprSymbol.getDeclarations();\n                if (declarations && declarations.length > 0) {\n                    const decl = declarations[0];\n                    if (Node.isVariableDeclaration(decl) || Node.isPropertyDeclaration(decl)) {\n                        return performFlowAnalysis(exprSymbol, decl, expr);\n                    }\n                }\n            }\n        }\n    } else if (Node.isBinaryExpression(expr)) {\n        const leftInfo = getNumericValueFromExpression(\n            expr.getLeft(),\n            symbol,\n            declaration,\n            usageNode,\n            currentValueInfo\n        );\n        const rightInfo = getNumericValueFromExpression(\n            expr.getRight(),\n            symbol,\n            declaration,\n            usageNode,\n            currentValueInfo\n        );\n\n        if (leftInfo && rightInfo) {\n            const operatorKind = expr.getOperatorToken().getKind();\n            return evaluateBinaryOperation(operatorKind, leftInfo, rightInfo);\n        }\n    }\n\n    return undefined;\n}\n\nfunction evaluateCompoundAssignment(\n    operatorKind: SyntaxKind,\n    leftInfo: NumericLiteralInfo,\n    rightInfo: NumericLiteralInfo\n): NumericLiteralInfo | undefined {\n    const operatorMap: { [key: number]: SyntaxKind } = {\n        [SyntaxKind.PlusEqualsToken]: SyntaxKind.PlusToken,\n        [SyntaxKind.MinusEqualsToken]: SyntaxKind.MinusToken,\n        [SyntaxKind.AsteriskEqualsToken]: SyntaxKind.AsteriskToken,\n        [SyntaxKind.SlashEqualsToken]: SyntaxKind.SlashToken,\n        [SyntaxKind.PercentEqualsToken]: SyntaxKind.PercentToken,\n    };\n    const binaryOperatorKind = operatorMap[operatorKind];\n    if (binaryOperatorKind !== undefined) {\n        return evaluateBinaryOperation(binaryOperatorKind, leftInfo, rightInfo);\n    }\n    return undefined;\n}\n\nfunction evaluateBinaryOperation(\n    operatorKind: SyntaxKind,\n    leftInfo: NumericLiteralInfo,\n    rightInfo: NumericLiteralInfo\n): NumericLiteralInfo | undefined {\n    let resultValue: number | undefined;\n    let hasDecimal = leftInfo.hasDecimal || rightInfo.hasDecimal;\n\n    switch (operatorKind) {\n        case SyntaxKind.PlusToken:\n            resultValue = leftInfo.value + rightInfo.value;\n            break;\n        case SyntaxKind.MinusToken:\n            resultValue = leftInfo.value - rightInfo.value;\n            break;\n        case SyntaxKind.AsteriskToken:\n            resultValue = leftInfo.value * rightInfo.value;\n            break;\n        case SyntaxKind.SlashToken:\n            resultValue = leftInfo.value / rightInfo.value;\n            hasDecimal = true; // Division can result in a decimal\n            break;\n        case SyntaxKind.PercentToken:\n            resultValue = leftInfo.value % rightInfo.value;\n            break;\n        default:\n            return undefined;\n    }\n\n    if (resultValue !== undefined) {\n        return {value: resultValue, hasDecimal};\n    }\n\n    return undefined;\n}\n\n","import {\n    SourceFile,\n    Node,\n    SyntaxKind,\n    CallExpression,\n    MethodDeclaration,\n    Type,\n    ClassDeclaration,\n    NewExpression,\n    TypeReferenceNode,\n    Identifier,\n    PropertyAccessExpression,\n    ElementAccessExpression,\n    InterfaceDeclaration, MethodSignature, TypeChecker\n} from \"ts-morph\";\nimport ts from \"typescript/lib/tsserverlibrary\";\nimport {\n    getIsUnityAPIType,\n    getIsUnityAPIDeclaration,\n    getGeniesScriptTypeFromType,\n    GeniesScriptType, getFullTypeName, AllowedUiInterfaces, getIsValidUnityGenericTypeArg, GET_ITEM_NAME, SET_ITEM_NAME\n} from \"./CompilerUtils\";\n\nconst CUSTOM_DIAGNOSTIC_CODES = {\n    INVALID_INHERITANCE: 10001,\n    FORBIDDEN_INTERFACE: 10002,\n    GENERIC_METHOD_MISSING_TYPE_ARGUMENTS: 10003,\n    GENERIC_METHOD_INVALID_TYPE_ARGUMENTS: 10004,\n    GENERIC_CLASS_MISSING_TYPE_ARGUMENTS: 10005,\n    GENERIC_CLASS_INVALID_TYPE_ARGUMENTS: 10006,\n    INVALID_GET_ITEM_ARGUMENTS: 10007,\n};\n\nconst ALLOWED_INHERITANCE_TYPES = new Set(['MonoBehaviour', 'ScriptableObject']);\n\nconst COMPONENT_METHODS = new Set([\n    'GetComponent',\n    'TryGetComponent',\n    'GetComponentInChildren',\n    'GetComponentsInChildren',\n    'GetComponentInParent',\n    'GetComponentsInParent',\n    'GetComponents',\n    'AddComponent',\n]);\n\n\nexport function getGeniesSemanticDiagnostics(file: SourceFile, typeChecker: TypeChecker): ts.Diagnostic[] {\n    if (!file) {\n        return [];\n    }\n\n    const diagnostics: ts.Diagnostic[] = [];\n\n    processClassDiagnostics(file, diagnostics);\n    processCallExpressionDiagnostics(file, diagnostics);\n    processTypeUsageDiagnostics(file, diagnostics);\n    \n    //TODO improve diagnostics for bracket access\n    //processBracketAccessDiagnostics(file, typeChecker, diagnostics);\n\n    return diagnostics;\n}\n\n//TODO improve diagnostics for bracket access\n// function processBracketAccessDiagnostics(file: SourceFile, typeChecker: TypeChecker, diagnostics: ts.Diagnostic[]) {\n//\n//     let expressions = file.getDescendantsOfKind(SyntaxKind.ElementAccessExpression);\n//\n//     if (expressions.length === 0) {\n//         return;\n//     }\n//\n//     expressions.forEach(node => {\n//         const elementAccess = node as ElementAccessExpression;\n//         const expression = elementAccess.getExpression();\n//         const argumentExpression = elementAccess.getArgumentExpression();\n//\n//         if (!argumentExpression) {\n//             // If there's no argument (e.g., obj[]), skip transformation\n//             return node;\n//         }\n//\n//         const type = expression.getType();\n//\n//         // Check if the type is a Unity API type\n//         if (!getIsUnityAPIType(type)) {\n//             return node;\n//         }\n//\n//         // Retrieve the symbol of the type\n//         const typeSymbol = type.getSymbol();\n//         if (!typeSymbol) {\n//             return;\n//         }\n//\n//         // Get all declarations (classes and interfaces) associated with the type\n//         const declarations = typeSymbol.getDeclarations().filter(\n//             decl => Node.isClassDeclaration(decl) || Node.isInterfaceDeclaration(decl)\n//         ) as (ClassDeclaration | InterfaceDeclaration)[];\n//\n//         if (declarations.length === 0) {\n//             return;\n//         }\n//\n//         // Collect all unique get_item and set_item methods across all declarations\n//         const getItemMethods: (MethodDeclaration | MethodSignature)[] = [];\n//         const setItemMethods: (MethodDeclaration | MethodSignature)[] = [];\n//\n//         const methodSignatures = new Set<string>();\n//\n//         declarations.forEach(decl => {\n//             const classOrInterface = decl as ClassDeclaration | InterfaceDeclaration;\n//\n//             // getMethods returns an array of MethodDeclaration or MethodSignature\n//             const methods = classOrInterface.getMethods();\n//\n//             methods.forEach(method => {\n//                 const methodName = method.getName();\n//                 if (methodName === GET_ITEM_NAME || methodName === SET_ITEM_NAME) {\n//                     // Generate a unique signature string for the method\n//                     const signature = method.getSignature().getDeclaration()?.getText();\n//                     if (signature && !methodSignatures.has(signature)) {\n//                         if (methodName === GET_ITEM_NAME) {\n//                             getItemMethods.push(method);\n//                         } else {\n//                             setItemMethods.push(method);\n//                         }\n//                         methodSignatures.add(signature);\n//                     }\n//                 }\n//             });\n//         });\n//\n//         if (getItemMethods.length === 0 && setItemMethods.length === 0) {\n//             return;\n//         }\n//\n//         const parent = elementAccess.getParent();\n//\n//         // Determine if this is a getter or setter\n//         if (\n//             Node.isBinaryExpression(parent) &&\n//             parent.getOperatorToken().getKind() === SyntaxKind.EqualsToken &&\n//             parent.getLeft() === elementAccess\n//         ) {\n//             // This is a setter: obj[index] = value\n//             if (setItemMethods.length === 0) {\n//                 return;\n//             }\n//\n//             const valueExpression = parent.getRight();\n//\n//             // Attempt to find a matching set_item method\n//             const matchingSetItem = setItemMethods.find(method => {\n//                 const params = method.getParameters();\n//                 if (params.length !== 2) {\n//                     return false;\n//                 }\n//\n//                 const indexParamType = params[0].getType();\n//                 const valueParamType = params[1].getType();\n//\n//                 const indexArgType = argumentExpression.getType();\n//                 const valueArgType = valueExpression.getType();\n//\n//                 return (\n//                     typeChecker.isTypeAssignableTo(indexArgType, indexParamType) &&\n//                     typeChecker.isTypeAssignableTo(valueArgType, valueParamType)\n//                 );\n//             });\n//\n//             if (!matchingSetItem) {\n//                 addDiagnostic(\n//                     diagnostics,\n//                     node,\n//                     `Invalid Assignment`,\n//                     CUSTOM_DIAGNOSTIC_CODES.INVALID_GET_ITEM_ARGUMENTS);\n//             }\n//         } else {\n//             // This is a getter: obj[index]\n//             if (getItemMethods.length === 0) {\n//                 return node;\n//             }\n//\n//             // Attempt to find a matching get_item method\n//             const matchingGetItem = getItemMethods.find(method => {\n//                 const params = method.getParameters();\n//                 if (params.length !== 1) {\n//                     return false;\n//                 }\n//\n//                 const indexParamType = params[0].getType();\n//                 const indexArgType = argumentExpression.getType();\n//\n//                 return typeChecker.isTypeAssignableTo(indexArgType, indexParamType);\n//             });\n//\n//             let validParams = getItemMethods.flatMap(g => g.getParameters().map(p => getFullTypeName(p.getType())));\n//\n//             if (!matchingGetItem) {\n//                 addDiagnostic(\n//                     diagnostics,\n//                     node,\n//                     `Invalid access, accepted types are '${validParams.join(\",\")}'`,\n//                     CUSTOM_DIAGNOSTIC_CODES.INVALID_GET_ITEM_ARGUMENTS);\n//             }\n//         }\n//     });\n// }\n\nfunction processClassDiagnostics(file: SourceFile, diagnostics: ts.Diagnostic[]) {\n    const geniesClasses = file.getClasses();\n\n    geniesClasses.forEach(cls => {\n        const baseClass = cls.getBaseClass();\n        const implementedInterfaces = cls.getImplements();\n        const baseClassName = baseClass?.getName();\n\n        if (baseClass && getIsUnityAPIType(baseClass.getType()) && baseClassName && !ALLOWED_INHERITANCE_TYPES.has(baseClassName)) {\n            const start = baseClass.getStart();\n            const length = baseClass.getName()?.length;\n\n            const diagnosticMessage = `Class '${cls.getName()}' inherits from a Unity type '${baseClass.getName()}' that is not 'MonoBehaviour' or 'ScriptableObject'.`;\n            const diagnostic: ts.Diagnostic = {\n                file: file.compilerNode,\n                start: start,\n                length: length,\n                messageText: diagnosticMessage,\n                category: ts.DiagnosticCategory.Error,\n                code: CUSTOM_DIAGNOSTIC_CODES.INVALID_INHERITANCE,\n                source: 'Genies',\n            };\n            diagnostics.push(diagnostic);\n        }\n\n        implementedInterfaces.forEach(intf => {\n            if (getIsUnityAPIType(intf.getType())) {\n\n                const typeName = getFullTypeName(intf.getType());\n                if (AllowedUiInterfaces.has(typeName)) {\n                    return;\n                }\n\n                const start = intf.getStart();\n                const length = intf.getWidth();\n\n                const diagnosticMessage = `Class '${cls.getName()}' implements a forbidden Unity interface '${intf.getText()}'.`;\n                const diagnostic: ts.Diagnostic = {\n                    file: file.compilerNode,\n                    start: start,\n                    length: length,\n                    messageText: diagnosticMessage,\n                    category: ts.DiagnosticCategory.Error,\n                    code: CUSTOM_DIAGNOSTIC_CODES.FORBIDDEN_INTERFACE,\n                    source: 'Genies',\n                };\n                diagnostics.push(diagnostic);\n            }\n        });\n    });\n}\n\nfunction processTypeUsageDiagnostics(file: SourceFile, diagnostics: ts.Diagnostic[]) {\n    // Gather all NewExpression and TypeReferenceNode instances\n    const newExpressions = file.getDescendantsOfKind(SyntaxKind.NewExpression);\n\n    // Process NewExpression nodes\n    newExpressions.forEach(newExpr => {\n        // Resolve the symbol of the class being instantiated\n        const typeSymbol = newExpr.getType().getSymbol();\n\n        if (!typeSymbol) {\n            return;\n        }\n\n        // Retrieve all declarations of the symbol\n        const declarations = typeSymbol.getDeclarations();\n\n        if (!declarations || declarations.length === 0) {\n            return;\n        }\n\n        // Filter for class declarations with type parameters (i.e., generic classes)\n        const classDeclarations = declarations.filter(decl =>\n            Node.isClassDeclaration(decl) && getIsUnityAPIDeclaration(decl) && decl.getTypeParameters().length > 0\n        ) as ClassDeclaration[];\n\n        if (classDeclarations.length === 0) {\n            return; // Not a generic class\n        }\n\n        const classDeclaration = classDeclarations[0];\n        const typeParams = classDeclaration.getTypeParameters();\n        const expectedTypeArgsCount = typeParams.length;\n\n        // Retrieve provided type arguments from the NewExpression\n        const typeArgs = newExpr.getTypeArguments();\n        const providedTypeArgsCount = typeArgs.length;\n\n        if (providedTypeArgsCount === 0) {\n            // Generic class used without type arguments\n            addDiagnostic(\n                diagnostics,\n                newExpr,\n                `Generic class '${getFullTypeName(newExpr.getType())}' must be instantiated with ${expectedTypeArgsCount} type argument(s).`,\n                CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_MISSING_TYPE_ARGUMENTS\n            );\n        } else {\n            if (providedTypeArgsCount !== expectedTypeArgsCount) {\n                // Incorrect number of type arguments provided\n                addDiagnostic(\n                    diagnostics,\n                    newExpr,\n                    `Generic class '${getFullTypeName(newExpr.getType())}' expects ${expectedTypeArgsCount} type argument(s), but got ${providedTypeArgsCount}.`,\n                    CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_INVALID_TYPE_ARGUMENTS\n                );\n            }\n\n            //Invalid args\n            typeArgs.forEach(typeArgNode => {\n                const typeArgType = typeArgNode.getType();\n                if (!getIsValidUnityGenericTypeArg(typeArgType)) {\n                    addDiagnostic(\n                        diagnostics,\n                        typeArgNode,\n                        `Type arguments for type '${getFullTypeName(newExpr.getType())}' must be Unity API types.`,\n                        CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_INVALID_TYPE_ARGUMENTS\n                    );\n                }\n            });\n\n        }\n    });\n}\n\n\nfunction processCallExpressionDiagnostics(file: SourceFile, diagnostics: ts.Diagnostic[]) {\n    const callExpressions = file.getDescendantsOfKind(SyntaxKind.CallExpression);\n\n    callExpressions.forEach(callExpr => {\n        processGenericMethodCall(callExpr, diagnostics);\n    });\n}\n\nfunction processGenericMethodCall(callExpr: CallExpression, diagnostics: ts.Diagnostic[]) {\n    const expression = callExpr.getExpression();\n\n    // Get the method symbol and all declarations\n    let methodDeclarations: MethodDeclaration[] = [];\n\n    if (Node.isPropertyAccessExpression(expression) || Node.isIdentifier(expression)) {\n        const methodSymbol = expression.getSymbol();\n        if (methodSymbol) {\n            const declarations = methodSymbol.getDeclarations();\n            methodDeclarations = declarations.filter(decl => Node.isMethodDeclaration(decl)) as MethodDeclaration[];\n        }\n    }\n\n    if (methodDeclarations.length === 0) {\n        return; // Cannot proceed without method declarations\n    }\n\n    let isGenericMethodDeclaration = methodDeclarations.filter(decl => {\n        return decl.getTypeParameters().length > 0\n    }).length > 0;\n\n    if (!isGenericMethodDeclaration) {\n        return;\n    }\n\n    // Filter to Unity API methods\n    methodDeclarations = methodDeclarations.filter(decl => getIsUnityAPIDeclaration(decl));\n\n    if (methodDeclarations.length === 0) {\n        return; // No Unity API methods\n    }\n\n    const methodName = getMethodName(expression);\n\n    // Check for non-generic overloads that accept the same parameters\n    if (hasMatchingNonGenericOverload(methodDeclarations, callExpr)) {\n        return; // Skip the check since a non-generic overload exists\n    }\n\n    // Now, ensure that the call provides type arguments\n    const typeArgs = callExpr.getTypeArguments();\n\n    if (typeArgs.length === 0) {\n        // Generic method called without specifying type arguments\n        addDiagnostic(\n            diagnostics,\n            callExpr,\n            `Generic method '${methodName}' must be called with type arguments.`,\n            CUSTOM_DIAGNOSTIC_CODES.GENERIC_METHOD_MISSING_TYPE_ARGUMENTS\n        );\n        return;\n    }\n\n    let validArgs = methodDeclarations.map(m => m.getTypeParameters().length);\n    if (!validArgs.includes(typeArgs.length)) {\n        // Incorrect number of type arguments provided\n        addDiagnostic(\n            diagnostics,\n            callExpr,\n            `Generic method '${methodName}' was provided the wrong number of arguments. Valid args counts: '${validArgs.join(\", \")}'`,\n            CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_INVALID_TYPE_ARGUMENTS\n        );\n    }\n\n    // Validate type arguments\n    if (COMPONENT_METHODS.has(methodName)) {\n        // Apply GetComponent rules\n        typeArgs.forEach(typeArgNode => {\n            if (!isValidComponentTypeArg(typeArgNode)) {\n                addDiagnostic(\n                    diagnostics,\n                    typeArgNode,\n                    `Type arguments for method '${methodName}' must be a Unity API type, an interface, or a type that extends MonoBehaviour.`,\n                    CUSTOM_DIAGNOSTIC_CODES.GENERIC_METHOD_INVALID_TYPE_ARGUMENTS\n                );\n            }\n        });\n    } else {\n        // For other methods, type arguments must be Unity API types\n        typeArgs.forEach(typeArgNode => {\n            const typeArgType = typeArgNode.getType();\n            if (!getIsValidUnityGenericTypeArg(typeArgType)) {\n                addDiagnostic(\n                    diagnostics,\n                    typeArgNode,\n                    `Type arguments for method '${methodName}' must be Unity API types.`,\n                    CUSTOM_DIAGNOSTIC_CODES.GENERIC_METHOD_INVALID_TYPE_ARGUMENTS\n                );\n            }\n        });\n    }\n}\n\nfunction hasMatchingNonGenericOverload(\n    methodDeclarations: MethodDeclaration[],\n    callExpr: CallExpression\n): boolean {\n    const callArgTypes = callExpr.getArguments().map(arg => arg.getType());\n    const typeChecker = callExpr.getProject().getTypeChecker();\n\n    return methodDeclarations.some(decl => {\n        if (decl.getTypeParameters().length > 0) {\n            return false; // It's a generic method\n        }\n\n        const parameters = decl.getParameters();\n        if (parameters.length !== callArgTypes.length) {\n            return false;\n        }\n\n        // Compare parameter types\n        for (let i = 0; i < parameters.length; i++) {\n            const paramType = parameters[i].getType();\n            const argType = callArgTypes[i];\n\n            if (!typeChecker.isTypeAssignableTo(argType, paramType)) {\n                return false;\n            }\n        }\n\n        return true; // Found a matching non-generic overload\n    });\n}\n\nfunction isValidComponentTypeArg(typeArgNode: Node): boolean {\n    const typeArgType = typeArgNode.getType();\n\n    if (getIsUnityAPIType(typeArgType)) {\n        // It's a Unity API type, acceptable\n        return true;\n    }\n\n    const geniesScriptType = getGeniesScriptTypeFromType(typeArgType);\n    if (geniesScriptType === GeniesScriptType.Monobehaviour) {\n        // It's a MonoBehaviour, acceptable\n        return true;\n    }\n\n    const symbol = typeArgType.getSymbol();\n    if (symbol) {\n        const declarations = symbol.getDeclarations();\n        if (declarations && declarations.length > 0) {\n            if (Node.isInterfaceDeclaration(declarations[0])) {\n                // It's an interface, acceptable\n                return true;\n            }\n        }\n    }\n\n    return false; // Invalid type argument\n}\n\nfunction getMethodName(expression: Node): string {\n    if (Node.isPropertyAccessExpression(expression)) {\n        return expression.getName();\n    } else if (Node.isIdentifier(expression)) {\n        return expression.getText();\n    } else {\n        return ''; // Unknown\n    }\n}\n\nfunction addDiagnostic(\n    diagnostics: ts.Diagnostic[],\n    node: Node,\n    messageText: string,\n    code: number\n) {\n    const start = node.getStart();\n    const length = node.getWidth();\n    const diagnostic: ts.Diagnostic = {\n        file: node.getSourceFile().compilerNode,\n        start: start,\n        length: length,\n        messageText: messageText,\n        category: ts.DiagnosticCategory.Error,\n        code: code,\n        source: 'Genies',\n    };\n    diagnostics.push(diagnostic);\n}\n","import {GeniesLSPContext} from \"./plugins/GeniesLSPContext\";\nimport {\n    BinaryExpression, ClassDeclaration,\n    Node,\n    PostfixUnaryExpression,\n    PrefixUnaryExpression, SyntaxKind,\n    Type, TypeChecker, TypeFlags\n} from \"ts-morph\";\nimport {\n    getIsUnityAPIType\n} from \"./CompilerUtils\";\nimport {typesAreEqual} from \"./MethodOverloadUtils\";\n\n// Modify to return the type if the operator method exists\nexport function getOperatorMethodReturnType(typeChecker : TypeChecker,\n                                            type: Type,\n                                            operatorMethodName: string,\n                                            rightType: Type): Type | null {\n    const typeSymbol = type.getSymbol();\n    if (!typeSymbol) {\n        return null;\n    }\n\n    const declarations = typeSymbol.getDeclarations();\n    for (const declaration of declarations) {\n        if (Node.isClassDeclaration(declaration)) {\n            const classDeclaration = declaration as ClassDeclaration;\n            const methods = classDeclaration.getMethods().filter(m => m.getName() === operatorMethodName && m.getTypeParameters().length === 0);\n\n            for (const method of methods) {\n                const parameters = method.getParameters();\n                if (parameters.length === 2) {\n                    const leftParameterType = parameters[0].getType();\n                    const rightParameterType = parameters[1].getType();\n\n                    const hasRightType = typesAreEqual(rightParameterType, rightType) || typeChecker.isTypeAssignableTo(rightType, rightParameterType);\n                    const hasLeftType = typesAreEqual(leftParameterType, type) || typeChecker.isTypeAssignableTo(type, leftParameterType);\n\n                    if (hasLeftType && hasRightType) {\n                        return method.getReturnType();\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nexport function getOperatorMethodName(\n    operatorKind: SyntaxKind,\n    isUnary: boolean = false\n): string | undefined {\n    if (isUnary) {\n        // Handle unary operators:\n        switch (operatorKind) {\n            case SyntaxKind.MinusToken:\n                // -a\n                return \"op_UnaryNegation\";\n            case SyntaxKind.PlusToken:\n                // +a\n                return \"op_UnaryPlus\";\n            case SyntaxKind.ExclamationToken:\n                // !a\n                return \"op_LogicalNot\";\n            case SyntaxKind.TildeToken:\n                // ~a\n                return \"op_OnesComplement\";\n            case SyntaxKind.PlusPlusToken:\n                // ++a or a++\n                return \"op_Increment\";\n            case SyntaxKind.MinusMinusToken:\n                // --a or a--\n                return \"op_Decrement\";\n            default:\n                return undefined;\n        }\n    } else {\n        // Handle binary operators:\n        switch (operatorKind) {\n            case SyntaxKind.PlusToken:\n                // a + b\n                return \"op_Addition\";\n            case SyntaxKind.MinusToken:\n                // a - b\n                return \"op_Subtraction\";\n            case SyntaxKind.AsteriskToken:\n                // a * b\n                return \"op_Multiply\";\n            case SyntaxKind.SlashToken:\n                // a / b\n                return \"op_Division\";\n            case SyntaxKind.PercentToken:\n                // a % b\n                return \"op_Modulus\";\n            case SyntaxKind.EqualsEqualsToken:\n            case SyntaxKind.EqualsEqualsEqualsToken:\n                // a == b\n                return \"op_Equality\";\n            case SyntaxKind.ExclamationEqualsToken:\n            case SyntaxKind.ExclamationEqualsEqualsToken:\n                // a != b\n                return \"op_Inequality\";\n            case SyntaxKind.GreaterThanToken:\n                // a > b\n                return \"op_GreaterThan\";\n            case SyntaxKind.LessThanToken:\n                // a < b\n                return \"op_LessThan\";\n            case SyntaxKind.GreaterThanEqualsToken:\n                // a >= b\n                return \"op_GreaterThanOrEqual\";\n            case SyntaxKind.LessThanEqualsToken:\n                // a <= b\n                return \"op_LessThanOrEqual\";\n            case SyntaxKind.BarToken:\n                // a | b\n                return \"op_BitwiseOr\";\n            case SyntaxKind.AmpersandToken:\n                // a & b\n                return \"op_BitwiseAnd\";\n            case SyntaxKind.CaretToken:\n                // a ^ b\n                return \"op_ExclusiveOr\";\n            case SyntaxKind.LessThanLessThanToken:\n                // a << b\n                return \"op_LeftShift\";\n            case SyntaxKind.GreaterThanGreaterThanToken:\n                // a >> b\n                return \"op_RightShift\";\n            // Add additional binary operators if needed.\n            default:\n                return undefined;\n        }\n    }\n}\n\nexport function unwrapParenthesizedExpression(node: Node): Node {\n    if (Node.isParenthesizedExpression(node)) {\n        return unwrapParenthesizedExpression(node.getExpression());\n    }\n    return node;\n}\n\nexport function isCompoundAssignment(operatorKind: SyntaxKind): boolean {\n    return operatorKind >= SyntaxKind.FirstCompoundAssignment && operatorKind <= SyntaxKind.LastCompoundAssignment;\n}\n\nexport function getEquivalentOperatorForCompound(compoundOperatorKind: SyntaxKind): SyntaxKind {\n    switch (compoundOperatorKind) {\n        case SyntaxKind.PlusEqualsToken:\n            return SyntaxKind.PlusToken;\n        case SyntaxKind.MinusEqualsToken:\n            return SyntaxKind.MinusToken;\n        case SyntaxKind.AsteriskEqualsToken:\n            return SyntaxKind.AsteriskToken;\n        case SyntaxKind.SlashEqualsToken:\n            return SyntaxKind.SlashToken;\n        case SyntaxKind.PercentEqualsToken:\n            return SyntaxKind.PercentToken;\n        case SyntaxKind.AmpersandEqualsToken:\n            return SyntaxKind.AmpersandToken;\n        case SyntaxKind.BarEqualsToken:\n            return SyntaxKind.BarToken;\n        case SyntaxKind.CaretEqualsToken:\n            return SyntaxKind.CaretToken;\n        case SyntaxKind.LessThanLessThanEqualsToken:\n            return SyntaxKind.LessThanLessThanToken;\n        case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n            return SyntaxKind.GreaterThanGreaterThanToken;\n        case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n            return SyntaxKind.GreaterThanGreaterThanGreaterThanToken;\n        default:\n            throw new Error(`Unsupported compound operator: ${SyntaxKind[compoundOperatorKind]}`);\n    }\n}\n\n// Modify to return the type if the unary operator method exists\nexport function getUnaryOperatorMethodReturnType(type: Type, operatorMethodName: string): Type | null {\n    const typeSymbol = type.getSymbol();\n    if (!typeSymbol) {\n        return null;\n    }\n\n    const declarations = typeSymbol.getDeclarations();\n    for (const declaration of declarations) {\n        if (Node.isClassDeclaration(declaration)) {\n            const classDeclaration = declaration as ClassDeclaration;\n            const methods = classDeclaration.getMethods().filter(m => m.getName() === operatorMethodName && m.getTypeParameters().length === 0);\n\n            for (const method of methods) {\n                const parameters = method.getParameters();\n                if (parameters.length === 1) {\n                    const operandType = parameters[0].getType();\n                    if (operandType.getText() === type.getText()) {\n                        return method.getReturnType();\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nexport function getOperatorNodeReturnType(node: Node, context: GeniesLSPContext): Type | null {\n    if (Node.isBinaryExpression(node)) {\n        return getBinaryOperatorNodeReturnType(node, context);\n    } else if (Node.isPrefixUnaryExpression(node) || Node.isPostfixUnaryExpression(node)) {\n        return getUnaryOperatorNodeReturnType(node, context);\n    }\n\n    return null;\n}\n\nfunction unwrapType(node: Node, context: GeniesLSPContext): Type | null {\n\n    if (Node.isBinaryExpression(node)) {\n        return getBinaryOperatorNodeReturnType(node, context);\n    } else if (Node.isPrefixUnaryExpression(node) || Node.isPostfixUnaryExpression(node)) {\n        return getUnaryOperatorNodeReturnType(node, context);\n    }\n\n    return context.TypeChecker.getTypeAtLocation(node);\n}\n\nfunction getBinaryOperatorNodeReturnType(node: BinaryExpression, context: GeniesLSPContext): Type | null {\n    const operatorToken = node.getOperatorToken();\n    const operatorKind = operatorToken.getKind();\n    let operatorMethodName = getOperatorMethodName(operatorKind);\n\n    if (isCompoundAssignment(operatorKind)) {\n        const equivalentOperatorKind = getEquivalentOperatorForCompound(operatorKind);\n        operatorMethodName = getOperatorMethodName(equivalentOperatorKind);\n    }\n\n    if (operatorMethodName == null) {\n        return null;\n    }\n\n    // Ignore transformations for '== null' and '== undefined'\n    if (operatorKind === SyntaxKind.EqualsEqualsEqualsToken\n        || operatorKind === SyntaxKind.EqualsEqualsToken\n        || operatorKind === SyntaxKind.ExclamationEqualsEqualsToken\n        || operatorKind == SyntaxKind.ExclamationEqualsToken) {\n        const right = unwrapParenthesizedExpression(node.getRight());\n        if (Node.isNullLiteral(right) || Node.isUndefinedKeyword(right)) {\n            return null;\n        }\n\n        const left = unwrapParenthesizedExpression(node.getLeft());\n        if (Node.isNullLiteral(left) || Node.isUndefinedKeyword(left)) {\n            return null;\n        }\n    }\n\n    const left = unwrapParenthesizedExpression(node.getLeft());\n    const right = unwrapParenthesizedExpression(node.getRight());\n\n    let leftType = unwrapType(left, context);\n    let rightType = unwrapType(right, context);\n\n    if (leftType == null || rightType == null) {\n        return null;\n    }\n\n    if (rightType.isLiteral()) {\n        rightType = context.TypeChecker.getBaseTypeOfLiteralType(rightType);\n    }\n\n    if (leftType.isLiteral()) {\n        leftType = context.TypeChecker.getBaseTypeOfLiteralType(leftType);\n    }\n\n    if (!getIsUnityAPIType(leftType) && !getIsUnityAPIType(rightType)) {\n        return context.TypeChecker.getTypeAtLocation(node);\n    }\n\n    const leftReturnType = getOperatorMethodReturnType(context.TypeChecker, leftType, operatorMethodName, rightType);\n    const rightReturnType = getOperatorMethodReturnType(context.TypeChecker, rightType, operatorMethodName, leftType);\n\n    if (leftReturnType == null && rightReturnType == null) {\n        return null;\n    }\n\n    // Handle compound assignments (+=, -=, etc.)\n    if (isCompoundAssignment(operatorKind)) {\n        const equivalentOperatorKind = getEquivalentOperatorForCompound(operatorKind);\n        const equivalentOperatorMethodName = getOperatorMethodName(equivalentOperatorKind);\n\n        if (equivalentOperatorMethodName == null) {\n            return null;\n        }\n\n        return getOperatorMethodReturnType(context.TypeChecker, leftType, equivalentOperatorMethodName, rightType);\n    }\n\n    return leftReturnType ?? rightReturnType;\n}\n\nfunction getUnaryOperatorNodeReturnType(node: PrefixUnaryExpression | PostfixUnaryExpression, context: GeniesLSPContext): Type | null {\n    const operand = unwrapParenthesizedExpression(node.getOperand());\n    const operatorKind = node.getOperatorToken();\n    const operatorMethodName = getOperatorMethodName(operatorKind, true);\n\n    if (operatorMethodName) {\n        const operandType = context.TypeChecker.getTypeAtLocation(operand);\n        return getUnaryOperatorMethodReturnType(operandType, operatorMethodName);\n    }\n\n    return null;\n}\n","import ts from \"typescript/lib/tsserverlibrary\";\nimport {Project, SourceFile, TypeChecker} from \"ts-morph\";\nimport {Node, Type} from \"ts-morph\";\n\nexport class GeniesLSPContext {\n    private readonly project: Project;\n    private readonly info: ts.server.PluginCreateInfo;\n    private inferredTypesCache: Map<Node, Type>;\n\n    constructor(project: Project, info: ts.server.PluginCreateInfo) {\n        this.project = project;\n        this.info = info;\n        this.inferredTypesCache = new Map<Node, Type>();\n    }\n\n    get LanguageServiceHost(): ts.LanguageServiceHost {\n        return this.info.languageServiceHost;\n    }\n\n    get LanguageService(): ts.LanguageService {\n        return this.info.languageService;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.info.project.projectService.logger;\n    }\n\n    get TypeChecker(): TypeChecker {\n        return this.project.getTypeChecker();\n    }\n\n    /**\n     * Retrieves a source file. If it doesn't exist, adds it to the project.\n     * Updates the source file content with the in-memory snapshot.\n     * @param fileName The name of the file.\n     * @returns The SourceFile or undefined.\n     */\n    getSourceFile(fileName: string): SourceFile | undefined {\n        let sourceFile = this.project.getSourceFile(fileName);\n        const snapshot = this.getInMemoryFileContent(fileName, this.info.languageServiceHost);\n\n        if (!sourceFile) {\n            if (snapshot) {\n                sourceFile = this.project.createSourceFile(fileName, snapshot, {overwrite: true});\n            } else {\n                sourceFile = this.project.addSourceFileAtPath(fileName);\n            }\n\n            if (!sourceFile) {\n                this.Logger.info(\"Source file not found.\");\n                return undefined;\n            }\n        } else {\n            // Update the content with the snapshot\n            if (snapshot) {\n                sourceFile.replaceWithText(snapshot);\n            } else {\n                // If snapshot is unavailable, refresh from file system\n                sourceFile.refreshFromFileSystemSync();\n            }\n        }\n\n        return sourceFile;\n    }\n\n    /**\n     * Retrieves the content of an in-memory file.\n     * @param fileName The name of the file.\n     * @param languageServiceHost The language service host.\n     * @returns The file content or undefined.\n     */\n    private getInMemoryFileContent(fileName: string, languageServiceHost: ts.LanguageServiceHost): string | undefined {\n        const scriptSnapshot = languageServiceHost.getScriptSnapshot(fileName);\n        return scriptSnapshot ? scriptSnapshot.getText(0, scriptSnapshot.getLength()) : undefined;\n    }\n\n    /**\n     * Registers an inferred type for a given node in the cache.\n     * @param node The AST node.\n     * @param type The inferred TypeScript type.\n     */\n    setInferredType(node: Node, type: Type): void {\n        this.inferredTypesCache.set(node, type);\n    }\n\n    /**\n     * Retrieves the inferred type for a given node from the cache.\n     * @param node The AST node.\n     * @returns The inferred TypeScript type or undefined.\n     */\n    getInferredType(node: Node): Type | undefined {\n        return this.inferredTypesCache.get(node);\n    }\n\n    /**\n     * Clears the inferred types cache. Useful when the project changes.\n     */\n    clearInferredTypes(): void {\n        this.inferredTypesCache.clear();\n    }\n}\n","import ts, { DiagnosticWithLocation} from 'typescript/lib/tsserverlibrary';\nimport {ILanguageServiceFeature} from './ILanguageServiceFeature';\nimport {isGeniesScriptType} from \"../CompilerUtils\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\nexport class GeniesScriptTypeDiagnostics implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetSuggestionDiagnostics = proxy.getSuggestionDiagnostics;\n        proxy.getSuggestionDiagnostics = (fileName: string): ts.DiagnosticWithLocation[] => {\n            const diagnostics = originalGetSuggestionDiagnostics(fileName);\n            return this.getSuggestionDiagnostics(diagnostics, fileName);\n        };\n    }\n\n    private getSuggestionDiagnostics(existingDiagnostics: DiagnosticWithLocation[], fileName: string): DiagnosticWithLocation[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return existingDiagnostics;\n        }\n\n        const specialClasses = sourceFile.getClasses()\n            .filter(cls => isGeniesScriptType(cls.getType()));\n\n\n        specialClasses.forEach(cls => {\n            const diagnosticsToRemove = existingDiagnostics.filter(diagnostic => {\n                this.Logger.info(`found class ${cls.getName()} with range ${cls.getStart()} - ${cls.getEnd()}`);\n                this.Logger.info(`Code = ${diagnostic.code}`);\n                this.Logger.info(`Diagnostic start = ${diagnostic.start}`);\n                this.Logger.info(`Diagnostic Message = ${diagnostic.messageText}`);\n                \n                return diagnostic.code === 6196 && diagnostic.start >= cls.getStart() && diagnostic.start <= cls.getEnd();\n            });\n\n            diagnosticsToRemove.forEach(diagnostic => {\n                const index = existingDiagnostics.indexOf(diagnostic);\n                if (index > -1) {\n                    existingDiagnostics.splice(index, 1);\n                }\n            });\n        });\n\n        return existingDiagnostics;\n    }\n\n}\n","module.exports = require(\"ts-morph\");","import ts from 'typescript/lib/tsserverlibrary';\nimport {ClassDeclaration, Node, SourceFile, SyntaxKind} from 'ts-morph';\nimport {ILanguageServiceFeature} from './ILanguageServiceFeature';\nimport {GeniesScriptType, getGeniesScriptTypeFromType} from \"../CompilerUtils\";\nimport {ScriptableObjectAllowedMethods, unityLifecycleMethods} from \"./GeniesLifecycleEvents\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\ntype getCompletionsAtPosition = (\n    fileName: string,\n    position: number,\n    options: ts.GetCompletionsAtPositionOptions | undefined\n) => ts.CompletionInfo | undefined;\n\ntype getCompletionEntryDetails = (\n    fileName: string,\n    position: number,\n    name: string,\n    formatOptions: ts.FormatCodeOptions | ts.FormatCodeSettings | undefined,\n    source: string | undefined,\n    preferences: ts.UserPreferences | undefined,\n    data: ts.CompletionEntryData | undefined\n) => ts.CompletionEntryDetails | undefined;\n\nexport class GeniesLifecycleEventsCompletions implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetCompletionsAtPosition = proxy.getCompletionsAtPosition;\n        proxy.getCompletionsAtPosition = (\n            fileName: string,\n            position: number,\n            options: ts.GetCompletionsAtPositionOptions | undefined\n        ): ts.CompletionInfo | undefined => {\n            return this.getCompletionsAtPosition(originalGetCompletionsAtPosition, fileName, position, options);\n        };\n\n        const originalGetCompletionEntryDetails = proxy.getCompletionEntryDetails;\n        proxy.getCompletionEntryDetails = (\n            fileName: string,\n            position: number,\n            name: string,\n            formatOptions: ts.FormatCodeOptions | ts.FormatCodeSettings | undefined,\n            source: string | undefined,\n            preferences: ts.UserPreferences | undefined,\n            data: ts.CompletionEntryData | undefined\n        ): ts.CompletionEntryDetails | undefined => {\n            return this.getCompletionEntryDetails(\n                originalGetCompletionEntryDetails,\n                fileName,\n                position,\n                name,\n                formatOptions,\n                source,\n                preferences,\n                data\n            );\n        };\n    }\n\n    getCompletionsAtPosition(\n        previousGetter: getCompletionsAtPosition,\n        fileName: string,\n        position: number,\n        options: ts.GetCompletionsAtPositionOptions | undefined\n    ): ts.CompletionInfo | undefined {\n        this.Logger.info(\"Getting completions at position.\");\n\n        const prior = previousGetter(fileName, position, options);\n        const completions: ts.CompletionEntry[] = [];\n\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return prior;\n        }\n\n        const filteredPriorEntries = prior?.entries.filter(entry => !unityLifecycleMethods.find(a => a.name === entry.name)) ?? [];\n\n        const relevantMethods = this.getRelevantMethods(sourceFile, position);\n        if (relevantMethods) {\n            completions.push(\n                ...relevantMethods.map(method => {\n                    // Construct the insertText using snippet syntax\n                    const insertText = `private ${method.name}(${method.parameters}) {\\n${method.description}\\t$0\\n}`;\n\n                    // Create the completion entry\n                    return {\n                        name: method.name,\n                        kind: ts.ScriptElementKind.memberFunctionElement,\n                        kindModifiers: 'private',\n                        sortText: '0',\n                        insertText: insertText,\n                        labelDetails: {\n                            description: method.description,\n                        },\n                        isSnippet: true as const,\n                        hasAction: true as const,\n                    } as ts.CompletionEntry;\n                })\n            );\n        }\n\n\n        this.Logger.info(\"Adding completions for Unity lifecycle methods.\");\n\n        return {\n            isGlobalCompletion: prior?.isGlobalCompletion ?? false,\n            isMemberCompletion: prior?.isMemberCompletion ?? false,\n            isNewIdentifierLocation: prior?.isNewIdentifierLocation ?? false,\n            entries: [...(filteredPriorEntries ?? []), ...completions],\n        };\n    }\n    \n    getCompletionEntryDetails(\n        previousGetter: getCompletionEntryDetails,\n        fileName: string,\n        position: number,\n        name: string,\n        formatOptions: ts.FormatCodeOptions | ts.FormatCodeSettings | undefined,\n        source: string | undefined,\n        preferences: ts.UserPreferences | undefined,\n        data: ts.CompletionEntryData | undefined\n    ): ts.CompletionEntryDetails | undefined {\n        const prior = previousGetter(fileName, position, name, formatOptions, source, preferences, data);\n        if (prior) {\n            return prior;\n        }\n\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return prior;\n        }\n\n        const relevantMethods = this.getRelevantMethods(sourceFile, position);\n        if (!relevantMethods) {\n            return prior;\n        }\n\n        const method = relevantMethods.find(m => m.name === name);\n        if (method) {\n            const displayParts: ts.SymbolDisplayPart[] = [\n                { text: \"private\", kind: \"keyword\" },\n                { text: \" \", kind: \"space\" },\n                { text: method.name, kind: \"methodName\" },\n                { text: \"(\", kind: \"punctuation\" },\n            ];\n\n            if (method.parameters) {\n                const params = method.parameters.split(',').map(param => param.trim());\n                for (let i = 0; i < params.length; i++) {\n                    const [paramName, paramType] = params[i].split(':').map(s => s.trim());\n                    displayParts.push({ text: paramName, kind: \"parameterName\" });\n                    displayParts.push({ text: \": \", kind: \"punctuation\" });\n                    displayParts.push({ text: paramType, kind: \"type\" });\n                    if (i < params.length - 1) {\n                        displayParts.push({ text: \", \", kind: \"punctuation\" });\n                    }\n                }\n            }\n\n            displayParts.push({ text: \")\", kind: \"punctuation\" });\n            displayParts.push({ text: \" \", kind: \"space\" });\n\n            const changes = this.createImportChanges(sourceFile, method.imports);\n\n            return {\n                name: method.name,\n                kind: ts.ScriptElementKind.memberFunctionElement,\n                kindModifiers: 'private',\n                displayParts: displayParts,\n                documentation: [{ text: method.description, kind: \"text\" }],\n                tags: [],\n                codeActions: changes.length > 0 ? [\n                    {\n                        description: `Add necessary imports for ${method.name}`,\n                        changes: changes,\n                    },\n                ] : undefined,\n            };\n        }\n\n        return undefined;\n    }\n\n    createImportChanges(\n        sourceFile: SourceFile,\n        imports: { type: string; module: string }[]\n    ): ts.CodeAction['changes'] {\n        const changes: ts.FileTextChanges[] = [];\n\n        // Gather existing imports\n        const importMap = new Map<string, Set<string>>();\n        sourceFile.getImportDeclarations().forEach(importDecl => {\n            const moduleSpecifier = importDecl.getModuleSpecifierValue();\n            const namedImports = new Set(importDecl.getNamedImports().map(namedImport => namedImport.getName()));\n            importMap.set(moduleSpecifier, namedImports);\n        });\n\n        // Update or add new imports\n        imports.forEach(imp => {\n            const existingImports = importMap.get(imp.module);\n            if (existingImports) {\n                if (!existingImports.has(imp.type)) {\n                    existingImports.add(imp.type);\n                }\n            } else {\n                importMap.set(imp.module, new Set([imp.type]));\n            }\n        });\n\n        // Convert import map to text changes\n        importMap.forEach((namedImports, moduleSpecifier) => {\n            const existingImport = sourceFile.getImportDeclaration(moduleSpecifier);\n            if (existingImport) {\n                const existingNamedImports = existingImport.getNamedImports().map(namedImport => namedImport.getName());\n                const newImports = Array.from(namedImports).filter(name => !existingNamedImports.includes(name));\n                if (newImports.length > 0) {\n                    const lastNamedImport = existingImport.getNamedImports().pop();\n                    if (lastNamedImport) {\n                        changes.push({\n                            fileName: sourceFile.getFilePath(),\n                            textChanges: [{\n                                newText: `, ${newImports.join(', ')}`,\n                                span: { start: lastNamedImport.getEnd(), length: 0 },\n                            }],\n                        });\n                    }\n                }\n            } else {\n                changes.push({\n                    fileName: sourceFile.getFilePath(),\n                    textChanges: [{\n                        newText: `import { ${Array.from(namedImports).join(', ')} } from '${moduleSpecifier}';\\n`,\n                        span: { start: 0, length: 0 },\n                    }],\n                });\n            }\n        });\n\n        return changes;\n    }\n\n    getRelevantMethods(\n        sourceFile: SourceFile,\n        position: number\n    ): Array<{\n        description: string;\n        name: string;\n        parameters: string;\n        imports: { type: string; module: string }[];\n    }> | undefined {\n        const node = sourceFile.getDescendantAtPos(position);\n        if (node) {\n            const classDeclaration = this.getEnclosingClassDeclaration(node, position);\n\n            if (classDeclaration) {\n                // Check if the position is within the class body\n                if (!this.isPositionInClassBodyOnly(classDeclaration, position)) {\n                    return undefined;\n                }\n\n                const type = classDeclaration.getType();\n\n                const geniesScriptType = getGeniesScriptTypeFromType(type);\n\n                if (geniesScriptType === GeniesScriptType.None) {\n                    this.Logger.info(\"No relevant methods found for the script type.\");\n                    return undefined;\n                }\n\n                const existingMethods = classDeclaration.getMethods().map(m => m.getName());\n                const unusedUnityMethods = unityLifecycleMethods.filter(um => !existingMethods.includes(um.name));\n\n                let relevantMethods: typeof unityLifecycleMethods = [];\n\n                if (geniesScriptType === GeniesScriptType.Monobehaviour) {\n                    relevantMethods = unusedUnityMethods;\n                } else if (geniesScriptType === GeniesScriptType.ScriptableObject) {\n                    relevantMethods = unusedUnityMethods.filter(method => ScriptableObjectAllowedMethods.includes(method.name));\n                }\n\n                return relevantMethods;\n            }\n        }\n\n        return undefined;\n    }\n\n    getEnclosingClassDeclaration(node: Node, position: number): ClassDeclaration | undefined {\n        let current: Node | undefined = node;\n        while (current) {\n            if (Node.isClassDeclaration(current)) {\n                const classStart = current.getStart();\n                const classEnd = current.getEnd();\n                if (classStart <= position && position <= classEnd) {\n                    return current as ClassDeclaration;\n                }\n            }\n            current = current.getParent();\n        }\n        return undefined;\n    }\n    isPositionInClassBodyOnly(classDeclaration: ClassDeclaration, position: number): boolean {\n        const openBraceToken = classDeclaration.getFirstChildByKind(SyntaxKind.OpenBraceToken);\n        const closeBraceToken = classDeclaration.getFirstChildByKind(SyntaxKind.CloseBraceToken);\n\n        if (!openBraceToken || !closeBraceToken) {\n            return false; // No class body braces, so nothing to complete within\n        }\n\n        const bodyStart = openBraceToken.getEnd();\n        const bodyEnd = closeBraceToken.getStart();\n\n        // Check if the position is within the class body boundaries\n        if (position < bodyStart || position > bodyEnd) {\n            return false;\n        }\n\n        // Get the node at the position and ensure it's directly within the class body scope\n        const nodeAtPosition = classDeclaration.getSourceFile().getDescendantAtPos(position);\n        if (!nodeAtPosition) return false;\n\n        const parent = nodeAtPosition.getParent();\n        const grandparent = parent?.getParent();\n\n        // Check if the node's parent is the class or the opening/closing brace, indicating it's in the class body\n        if (parent === classDeclaration || parent === openBraceToken || parent === closeBraceToken || grandparent === classDeclaration) {\n            return true;\n        }\n\n        return false; // Otherwise, the position is likely inside a member\n    }\n\n}\n","import ts, {DiagnosticWithLocation} from 'typescript/lib/tsserverlibrary';\nimport {ILanguageServiceFeature} from './ILanguageServiceFeature';\nimport {unityLifecycleMethods} from './GeniesLifecycleEvents';\nimport {isGeniesScriptType} from \"../CompilerUtils\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\nexport class GeniesLifecycleEventsDiagnostics implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetSuggestionDiagnostics = proxy.getSuggestionDiagnostics;\n        proxy.getSuggestionDiagnostics = (fileName: string): ts.DiagnosticWithLocation[] => {\n            const diagnostics = originalGetSuggestionDiagnostics(fileName);\n            return this.getSuggestionDiagnostics(diagnostics, fileName);\n        };\n    }\n\n    private getSuggestionDiagnostics(existingDiagnostics: DiagnosticWithLocation[], fileName: string): DiagnosticWithLocation[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if(!sourceFile)\n        {\n            return existingDiagnostics;\n        }\n        \n        const unityMethodNames = new Set(unityLifecycleMethods.map(method => method.name));\n        const specialMethods = sourceFile.getClasses()\n            .filter(cls => isGeniesScriptType(cls.getType()))\n            .flatMap(cls => cls.getMethods())\n            .filter(m => unityMethodNames.has(m.getName()));\n\n        specialMethods.forEach(method => {\n            const diagnosticsToRemove = existingDiagnostics.filter(diagnostic => {\n                return diagnostic.code === 6133 && diagnostic.start === method.getNameNode().getStart();\n            });\n            diagnosticsToRemove.forEach(diagnostic => {\n                const index = existingDiagnostics.indexOf(diagnostic);\n                if (index > -1) {\n                    existingDiagnostics.splice(index, 1);\n                }\n            });\n        });\n\n        return existingDiagnostics;\n    }\n}\n","import ts from 'typescript/lib/tsserverlibrary';\nimport { ILanguageServiceFeature } from './ILanguageServiceFeature';\nimport { GeniesLSPContext } from \"./GeniesLSPContext\";\nimport {getGeniesSemanticDiagnostics} from \"../GeniesDiagnosticsUtils\";\n\nexport class GeniesSemanticDiagnostics implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetSemanticDiagnostics = proxy.getSemanticDiagnostics;\n        proxy.getSemanticDiagnostics = (fileName: string): ts.Diagnostic[] => {\n            let diagnostics = originalGetSemanticDiagnostics(fileName);\n            diagnostics = this.getGeniesSemanticDiagnostics(diagnostics, fileName);\n            return diagnostics;\n        };\n    }\n\n    private getGeniesSemanticDiagnostics(existingDiagnostics: ts.Diagnostic[], fileName: string): ts.Diagnostic[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return existingDiagnostics;\n        }\n\n        // Clear existing diagnostics to prevent duplicate additions\n        const newDiagnostics: ts.Diagnostic[] = getGeniesSemanticDiagnostics(sourceFile, this.context.TypeChecker);\n        \n        // Remove previous diagnostics that share the same message and range\n        const uniqueExistingDiagnostics = existingDiagnostics.filter(existingDiag =>\n            !newDiagnostics.some(newDiag =>\n                newDiag.messageText === existingDiag.messageText &&\n                newDiag.start === existingDiag.start &&\n                newDiag.length === existingDiag.length\n            )\n        );\n\n        return [...uniqueExistingDiagnostics, ...newDiagnostics];\n    }\n}\n","module.exports = require(\"path\");","module.exports = require(\"typescript/lib/tsserverlibrary\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(26);\n"],"names":["root","factory","exports","module","define","amd","this","modules","project","context","create","info","projectService","logger","Project","compilerOptions","getCompilerOptions","skipAddingFilesFromTsConfig","setProjectRoot","getFileSystem","getCurrentDirectory","GeniesLSPContext","features","GeniesLifecycleEventsCompletions","CSharpOperatorOverloadingSuppress","GeniesLifecycleEventsDiagnostics","GeniesScriptTypeDiagnostics","GeniesSemanticDiagnostics","proxy","Object","k","keys","languageService","x","args","apply","forEach","feature","enhanceProxy","constructor","expressionValidity","Logger","originalGetSemanticDiagnostics","getSemanticDiagnostics","fileName","previousGetter","priorDiagnostics","sourceFile","getSourceFile","collectExpressions","diagnostics","filter","diagnostic","start","end","length","expr","valid","isCastable","fromType","toType","isAssignableTo","binaryExpressions","getDescendantsOfKind","SyntaxKind","BinaryExpression","prefixUnaryExpressions","PrefixUnaryExpression","postfixUnaryExpressions","PostfixUnaryExpression","processNode","node","getStart","getEnd","finalType","getOperatorNodeReturnType","getText","push","assignmentExpressions","getOperatorToken","getKind","EqualsToken","assign","rhs","getRight","rhsStart","rhsEnd","some","variableDecls","VariableDeclaration","v","init","getInitializer","initStart","initEnd","asExpressions","AsExpression","asExp","subExp","getExpression","subStart","subEnd","subType","TypeChecker","getTypeAtLocation","castType","getTypeNodeOrThrow","unityLifecycleMethods","name","parameters","description","imports","type","ScriptableObjectAllowedMethods","GeniesScriptUiEvents","projectRoot","GeniesDeclarationFileAnnotation","GeniesInstancePropName","MonobehaviourTypeName","ScriptableObjectTypeName","NonSerializedDecorator","HideInInspectorDecorator","SerializeFieldDecorator","HeaderDecorator","SpaceDecorator","TooltipDecorator","GET_ITEM_NAME","SET_ITEM_NAME","componentMethods","Set","AllowedUiInterfaces","UiInterfaceToEnumMap","Map","PointerClick","PointerDown","PointerEnter","PointerExit","PointerUp","BeginDrag","Deselect","Drag","Drop","EndDrag","InitializePotentialDrag","Scroll","Select","Submit","UpdateSelected","Move","Cancel","AliasToTypeName","AliasToFullTypeName","GeniesScriptType","extendsMonoBehaviour","classDecl","baseClass","getBaseClass","getName","extendsScriptableObject","inheritsFrom","baseNames","transformationContext","baseTypes","symbol","getSymbol","declarations","getDeclarations","declaration","Node","isClassDeclaration","heritageClauses","getHeritageClauses","heritageClause","types","getTypeNodes","typeNode","baseType","typeChecker","getBaseTypes","baseTypeName","includes","getFullTypeName","forCsharp","includeArguments","text","aliasSymbol","getAliasSymbol","has","get","getIsUnityAPIType","getFullyQualifiedName","replace","isExported","decl","isInterfaceDeclaration","sourceFilePath","getFilePath","relativePath","convertToAliasPath","parsedPath","path","parse","filePathWithoutExt","join","dir","parsed","aliasPath","convertToGeniesAliasPath","regex","test","typeArguments","getTypeArguments","arg","index","argText","extractProperties","cls","basePath","typeArgumentMap","properties","getProperties","prop","visibility","getScope","decorators","extractDecorators","isStatic","isReadonly","d","Type","resolveGenericType","getType","isArray","resolvedType","resolveArrayElementType","typeName","propName","fullPath","expression","NewExpression","newExpression","getArguments","map","PropertyAccessExpression","pae","initializerExpressions","hasInitializer","initializer","ArrayLiteralExpression","arrayLiteral","i","getElements","element","propertyInfo","Path","Name","TypeName","ChildProperties","IsArray","IsEnum","EnumKeys","EnumValues","Decorators","IsGeniesBehaviourRef","IsGeniesScriptableObjectRef","Initializers","ArrayElementInitializer","undefined","ArrayDimension","dimension","getArrayElementInitializer","fillExtraPropertyInfo","isEnum","isUnityType","getIsUnityAPIDeclaration","geniesScriptType","getGeniesScriptTypeFromNode","Monobehaviour","ScriptableObject","None","values","find","dec","EnumDeclaration","getMembers","member","getValue","extractEnumDetails","value","toString","fillEnumInfo","typeParams","getTypeParameters","typeArgs","newTypeArgumentMap","param","uniqueParamName","set","childProperties","unshift","newBase","underlyingTypeName","propPath","getArrayElementType","currentDimension","isTypeParameter","parentDecl","getParent","uniqueTypeName","getIsUnityAPISourceFile","firstNode","getFirstChild","console","log","leadingComments","getLeadingCommentRanges","s","getApparentType","ClassDeclaration","isMonobehaviour","isScriptableObject","getGeniesScriptTypeFromType","absolutePath","normalizedPath","split","sep","assetsIndex","indexOf","substring","assetsPrefix","comGeniesMatch","match","resolve","getDecorators","Args","a","NumericalAliases","condition","decorator","remove","classDeclaration","resultSet","currentClass","classTypeName","add","getImplements","implementClause","queue","currentIfaceType","shift","ifaceName","Array","from","allStatements","getStatements","importDeclarations","stmt","ImportDeclaration","variableStatements","VariableStatement","otherStatements","newText","replaceWithText","varStatements","lastImportIndex","lastGenericTypeVarIndex","statements","getLastImportIndex","statementsLength","Math","min","insertVariableStatements","typeModule","scriptType","Error","csTypeName","lastDotIndex","lastIndexOf","existingImport","getImportDeclarations","importDecl","getModuleSpecifierValue","getNamedImports","namedImport","addNamedImport","importStructure","kind","StructureKind","moduleSpecifier","namedImports","addImportDeclaration","argType","resolveName","SymbolFlags","All","getDeclaredTypeOfSymbol","typeText","trim","isPropertyAccessExpression","isThisExpression","getNameNode","isIdentifier","gType","filePath","getDirectoryPath","importDeclaration","startsWith","setModuleSpecifier","inferPossibleTypes","inferredTypeNames","brandedType","getTypeByName","getBrandedTypes","numericInfo","getNumericValue","hasDecimal","inferTypesFromNumericInfo","cleanTypeText","scoreOverload","overload","argumentTypesList","getParameters","score","paramType","argTypes","argScore","scoreParameter","possibleArgTypes","bestScore","constraint","getConstraint","typesAreEqual","max","isTypeAssignableTo","isValidNumericalType","isNumericCastable","fromTypeName","toTypeName","byte","sbyte","short","ushort","int","uint","float","double","number","type1","type2","numericLiteralInfo","getNumericLiteralInfo","isVariableDeclaration","isPropertyDeclaration","valueInfo","performFlowAnalysis","isNumericLiteral","Number","isPrefixUnaryExpression","MinusToken","operand","getOperand","usageNode","currentValueInfo","initValueInfo","getNumericValueFromExpression","methodDeclaration","getFirstAncestorByKind","MethodDeclaration","usageStart","assignments","getDescendants","isBinaryExpression","isPostfixUnaryExpression","assignment","operatorKind","left","getLeft","right","isAssignmentToSymbol","PlusEqualsToken","MinusEqualsToken","AsteriskEqualsToken","SlashEqualsToken","PercentEqualsToken","evaluateCompoundAssignment","delta","PlusPlusToken","exprSymbol","leftInfo","rightInfo","evaluateBinaryOperation","binaryOperatorKind","PlusToken","AsteriskToken","SlashToken","PercentToken","resultValue","overloads","callExpression","callArgs","bestOverload","highestScore","CUSTOM_DIAGNOSTIC_CODES","ALLOWED_INHERITANCE_TYPES","COMPONENT_METHODS","addDiagnostic","messageText","code","getWidth","file","compilerNode","category","DiagnosticCategory","source","getClasses","implementedInterfaces","baseClassName","diagnosticMessage","intf","processClassDiagnostics","CallExpression","callExpr","methodDeclarations","methodSymbol","isMethodDeclaration","methodName","getMethodName","callArgTypes","getProject","getTypeChecker","hasMatchingNonGenericOverload","validArgs","m","typeArgNode","typeArgType","isValidComponentTypeArg","getIsValidUnityGenericTypeArg","processGenericMethodCall","processCallExpressionDiagnostics","newExpr","typeSymbol","classDeclarations","expectedTypeArgsCount","providedTypeArgsCount","processTypeUsageDiagnostics","getOperatorMethodReturnType","operatorMethodName","rightType","methods","getMethods","method","leftParameterType","rightParameterType","hasRightType","getReturnType","getOperatorMethodName","isUnary","ExclamationToken","TildeToken","MinusMinusToken","EqualsEqualsToken","EqualsEqualsEqualsToken","ExclamationEqualsToken","ExclamationEqualsEqualsToken","GreaterThanToken","LessThanToken","GreaterThanEqualsToken","LessThanEqualsToken","BarToken","AmpersandToken","CaretToken","LessThanLessThanToken","GreaterThanGreaterThanToken","unwrapParenthesizedExpression","isParenthesizedExpression","isCompoundAssignment","FirstCompoundAssignment","LastCompoundAssignment","getEquivalentOperatorForCompound","compoundOperatorKind","AmpersandEqualsToken","BarEqualsToken","CaretEqualsToken","LessThanLessThanEqualsToken","GreaterThanGreaterThanEqualsToken","GreaterThanGreaterThanGreaterThanEqualsToken","GreaterThanGreaterThanGreaterThanToken","getUnaryOperatorMethodReturnType","unwrapType","getBinaryOperatorNodeReturnType","getUnaryOperatorNodeReturnType","isNullLiteral","isUndefinedKeyword","leftType","isLiteral","getBaseTypeOfLiteralType","leftReturnType","rightReturnType","equivalentOperatorMethodName","inferredTypesCache","LanguageServiceHost","languageServiceHost","LanguageService","snapshot","getInMemoryFileContent","refreshFromFileSystemSync","createSourceFile","overwrite","addSourceFileAtPath","scriptSnapshot","getScriptSnapshot","getLength","setInferredType","getInferredType","clearInferredTypes","clear","originalGetSuggestionDiagnostics","getSuggestionDiagnostics","existingDiagnostics","isGeniesScriptType","splice","require","originalGetCompletionsAtPosition","getCompletionsAtPosition","position","options","originalGetCompletionEntryDetails","getCompletionEntryDetails","formatOptions","preferences","data","prior","completions","filteredPriorEntries","entries","entry","relevantMethods","getRelevantMethods","insertText","ScriptElementKind","memberFunctionElement","kindModifiers","sortText","labelDetails","isSnippet","hasAction","isGlobalCompletion","isMemberCompletion","isNewIdentifierLocation","displayParts","params","paramName","changes","createImportChanges","documentation","tags","codeActions","importMap","imp","existingImports","getImportDeclaration","existingNamedImports","newImports","lastNamedImport","pop","textChanges","span","getDescendantAtPos","getEnclosingClassDeclaration","isPositionInClassBodyOnly","existingMethods","unusedUnityMethods","um","current","classStart","classEnd","openBraceToken","getFirstChildByKind","OpenBraceToken","closeBraceToken","CloseBraceToken","bodyStart","bodyEnd","nodeAtPosition","parent","grandparent","unityMethodNames","flatMap","getGeniesSemanticDiagnostics","newDiagnostics","existingDiag","newDiag","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}