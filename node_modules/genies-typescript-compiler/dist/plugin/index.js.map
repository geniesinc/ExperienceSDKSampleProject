{"version":3,"file":"index.js","mappings":"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","sources":["file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/webpack/universalModuleDefinition","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/index.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/CSharpOperatorOverloadingSupress.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesLifecycleEvents.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/CompilerUtils.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/MethodOverloadUtils.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/GeniesDiagnosticsUtils.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/OperatorOverloadingUtils.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesLSPContext.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesScriptTypeDiagnostics.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/external commonjs \"ts-morph\"","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesLifecycleEventsCompletions.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesLifecycleEventsDiagnostics.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/src/plugins/GeniesInheritanceDiagnostics.ts","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/external node-commonjs \"path\"","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/external commonjs \"typescript/lib/tsserverlibrary\"","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/webpack/bootstrap","file:///Users/rdalaq/Desktop/Projects/genies-unity-packages/internal/com.genies.scripting.internal/Editor/Compiler/Project~/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"genies-typescript-compiler-plugin\"] = factory();\n\telse\n\t\troot[\"genies-typescript-compiler-plugin\"] = factory();\n})(this, () => {\nreturn ","import ts from 'typescript/lib/tsserverlibrary';\nimport { Project } from 'ts-morph';\nimport { tss } from './types';\nimport { ILanguageServiceFeature } from \"./ILanguageServiceFeature\";\nimport { GeniesLifecycleEventsCompletions } from \"./GeniesLifecycleEventsCompletions\";\nimport { CSharpOperatorOverloadingSuppress } from \"./CSharpOperatorOverloadingSupress\";\nimport { GeniesLifecycleEventsDiagnostics } from \"./GeniesLifecycleEventsDiagnostics\";\nimport { GeniesScriptTypeDiagnostics } from \"./GeniesScriptTypeDiagnostics\";\nimport { GeniesLSPContext } from \"./GeniesLSPContext\";\nimport { GeniesSemanticDiagnostics } from \"./GeniesInheritanceDiagnostics\";\nimport {setProjectRoot} from \"../CompilerUtils\";\n\nconst init = (modules: { typescript: tss }) => {\n    let project: Project;\n    let context: GeniesLSPContext;\n\n    function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n        info.project.projectService.logger.info(\"I'm getting set up now! Check the log for this message.\");\n\n        // Create a ts-morph project using the existing tsconfig\n        project = new Project({\n            compilerOptions: info.project.getCompilerOptions(),\n            skipAddingFilesFromTsConfig: true,\n        });\n\n        setProjectRoot(project.getFileSystem().getCurrentDirectory());\n\n        context = new GeniesLSPContext(project, info);\n\n        const features: ILanguageServiceFeature[] = [\n            new GeniesLifecycleEventsCompletions(context),\n            new CSharpOperatorOverloadingSuppress(context),\n            new GeniesLifecycleEventsDiagnostics(context),\n            new GeniesScriptTypeDiagnostics(context),\n            new GeniesSemanticDiagnostics(context)\n            // Add other features here\n        ];\n\n        const proxy: ts.LanguageService = Object.create(null);\n        for (const k of Object.keys(info.languageService) as Array<keyof ts.LanguageService>) {\n            const x = info.languageService[k]!;\n            //@ts-expect-error\n            proxy[k] = (...args: Array<{}>) => x.apply(info.languageService, args);\n        }\n\n        features.forEach(feature => feature.enhanceProxy(proxy));\n        return proxy;\n    }\n\n    return { create };\n}\n\nexport = init;\n","import {LanguageService} from \"typescript\";\nimport {ILanguageServiceFeature} from \"./ILanguageServiceFeature\";\nimport {Node, SourceFile, SyntaxKind, Type} from \"ts-morph\";\nimport ts from \"typescript/lib/tsserverlibrary\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\nimport {getOperatorNodeReturnType} from \"../OperatorOverloadingUtils\";\n\ntype getSemanticDiagnostics = (fileName: string) => ts.Diagnostic[];\n\ninterface ExpressionValidityInfo {\n    start: number;\n    end: number;\n    valid: boolean;\n}\n\nexport class CSharpOperatorOverloadingSuppress implements ILanguageServiceFeature {\n    // List of diagnostic error codes related to operator overloading to suppress\n    private static OPERATOR_ERROR_CODES = [\n        2365,  // Operator cannot be applied to types\n        2363,  // The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type\n        2362,  // The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type\n        2322,  //Type '{0}' is not assignable to type '{1}'.\"\n        2345,  //Argument of type '{0}' is not assignable to parameter of type '{1}'.\n        2352,  //Neither type '{0}' nor type '{1}' is assignable to the other.\"\n        2315   //Type '{0}' is not generic.\n    ];\n\n    private expressionValidity: ExpressionValidityInfo[] = [];\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: LanguageService): void {\n        const originalGetSemanticDiagnostics = proxy.getSemanticDiagnostics;\n        proxy.getSemanticDiagnostics = (fileName: string): ts.Diagnostic[] => {\n            return this.getSemanticDiagnostics(originalGetSemanticDiagnostics, fileName);\n        };\n    }\n\n    getSemanticDiagnostics(previousGetter: getSemanticDiagnostics, fileName: string): ts.Diagnostic[] {\n        const priorDiagnostics = previousGetter(fileName);\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return priorDiagnostics;\n        }\n\n        // Collect all expressions and their validity\n        this.collectExpressions(sourceFile);\n\n        // More selective filtering of diagnostics\n        const diagnostics = priorDiagnostics.filter(diagnostic => {\n            // If we don't have a valid location, keep the diagnostic\n            if (diagnostic.start === undefined || diagnostic.length === undefined) {\n                return true;\n            }\n\n            const start = diagnostic.start;\n            const end = start + diagnostic.length;\n            const code = diagnostic.code;\n\n            // Only suppress specific operator-related error codes\n            if (!CSharpOperatorOverloadingSuppress.OPERATOR_ERROR_CODES.includes(Number(code))) {\n                return true;\n            }\n\n            // Check if this diagnostic overlaps with any of our valid expressions\n            for (const expr of this.expressionValidity) {\n                // Check if the diagnostic is contained within a valid expression range\n                // AND if this particular error code should be suppressed for this expression\n                if (expr.valid &&\n                    start >= expr.start && end <= expr.end) {\n                    return false; // Suppress this diagnostic\n                }\n            }\n            return true;\n        });\n\n        // Clear the map for the next file\n        this.expressionValidity = [];\n        return diagnostics;\n    }\n\n    collectExpressions(sourceFile: SourceFile) {\n        const binaryExpressions = sourceFile!.getDescendantsOfKind(SyntaxKind.BinaryExpression);\n        const prefixUnaryExpressions = sourceFile!.getDescendantsOfKind(SyntaxKind.PrefixUnaryExpression);\n        const postfixUnaryExpressions = sourceFile!.getDescendantsOfKind(SyntaxKind.PostfixUnaryExpression);\n\n        const processNode = (node: Node) => {\n            const start = node.getStart();\n            const end = node.getEnd();\n            const finalType = getOperatorNodeReturnType(node, this.context);\n\n            const valid = finalType != null;\n            this.context.Logger.info(`[FOUND TYPE] ${finalType?.getText()} at Node ${node.getText()}`);\n\n            // Store more specific data about which errors to suppress\n            this.expressionValidity.push({\n                start,\n                end,\n                valid\n            });\n        };\n\n        binaryExpressions.forEach(processNode);\n        prefixUnaryExpressions.forEach(processNode);\n        postfixUnaryExpressions.forEach(processNode);\n\n        const assignmentExpressions = binaryExpressions.filter(expr => {\n            return expr.getOperatorToken().getKind() === SyntaxKind.EqualsToken;\n        });\n\n        for (const assign of assignmentExpressions) {\n            const rhs = assign.getRight();\n            const rhsStart = rhs.getStart();\n            const rhsEnd = rhs.getEnd();\n\n            // Check if the right side was recognized as valid\n            const recognized = this.expressionValidity.some(\n                expr => expr.valid && expr.start <= rhsStart && expr.end >= rhsEnd\n            );\n            if (recognized) {\n                // Mark the entire assignment as valid, but only for specific operator errors\n                this.expressionValidity.push({\n                    start: assign.getStart(),\n                    end: assign.getEnd(),\n                    valid: true\n                });\n            }\n        }\n\n        const variableDecls = sourceFile.getDescendantsOfKind(SyntaxKind.VariableDeclaration);\n        for (const v of variableDecls) {\n            const init = v.getInitializer();\n            if (!init) continue;\n\n            // Check if the initializer is recognized\n            const initStart = init.getStart();\n            const initEnd = init.getEnd();\n            const recognized = this.expressionValidity.some(\n                expr => expr.valid && expr.start <= initStart && expr.end >= initEnd\n            );\n\n            // If recognized, add a range covering the entire declaration\n            if (recognized) {\n                this.expressionValidity.push({\n                    start: v.getStart(),\n                    end: v.getEnd(),\n                    valid: true\n                });\n            }\n        }\n\n        const asExpressions = sourceFile.getDescendantsOfKind(SyntaxKind.AsExpression);\n        for (const asExp of asExpressions) {\n            // This is the \"foo as SomeType\" node\n            const subExp = asExp.getExpression();\n\n            // Check if the sub-expression was recognized as valid\n            const subStart = subExp.getStart();\n            const subEnd = subExp.getEnd();\n            const recognizedSub = this.expressionValidity.some(\n                expr => expr.valid && expr.start <= subStart && expr.end >= subEnd\n            );\n\n            if (!recognizedSub) {\n                continue;\n            }\n\n            const subType = getOperatorNodeReturnType(subExp, this.context)\n                ?? this.context.TypeChecker.getTypeAtLocation(subExp);\n            // The \"as\" type from \"foo as T\"\n            const castType = this.context.TypeChecker.getTypeAtLocation(asExp.getTypeNodeOrThrow());\n\n            // If subType -> castType is valid, then mark the entire \"foo as T\" node range\n            if (subType.isAssignableTo(castType)) {\n                this.expressionValidity.push({\n                    start: asExp.getStart(),\n                    end: asExp.getEnd(),\n                    valid: true\n                });\n            }\n        }\n    }\n}","\n// Unity lifecycle methods\nexport const unityLifecycleMethods = [\n    { name: \"Awake\", parameters: \"\", description: \"Called when the script instance is being loaded.\", imports: [] },\n    { name: \"Start\", parameters: \"\", description: \"Called before the first frame update.\", imports: [] },\n    { name: \"OnEnable\", parameters: \"\", description: \"Called when the object becomes enabled and active.\", imports: [] },\n    { name: \"OnDisable\", parameters: \"\", description: \"Called when the object becomes disabled.\", imports: [] },\n    { name: \"OnDestroy\", parameters: \"\", description: \"Called when the MonoBehaviour will be destroyed.\", imports: [] },\n    { name: \"Update\", parameters: \"\", description: \"Called once per frame.\", imports: [] },\n    { name: \"FixedUpdate\", parameters: \"\", description: \"Called every fixed frame-rate frame.\", imports: [] },\n    { name: \"LateUpdate\", parameters: \"\", description: \"Called once per frame after Update.\", imports: [] },\n    { name: \"OnCollisionEnter\", parameters: \"collision: Collision\", description: \"Called when this collider/rigidbody has begun touching another rigidbody/collider.\", imports: [{ type: \"Collision\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionExit\", parameters: \"collision: Collision\", description: \"Called when this collider/rigidbody has stopped touching another rigidbody/collider.\", imports: [{ type: \"Collision\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionStay\", parameters: \"collision: Collision\", description: \"Called once per frame for every collider/rigidbody that is touching rigidbody/collider.\", imports: [{ type: \"Collision\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionEnter2D\", parameters: \"collision: Collision2D\", description: \"Called when this collider/rigidbody has begun touching another rigidbody/collider in 2D.\", imports: [{ type: \"Collision2D\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionExit2D\", parameters: \"collision: Collision2D\", description: \"Called when this collider/rigidbody has stopped touching another rigidbody/collider in 2D.\", imports: [{ type: \"Collision2D\", module: \"UnityEngine\" }] },\n    { name: \"OnCollisionStay2D\", parameters: \"collision: Collision2D\", description: \"Called once per frame for every collider/rigidbody that is touching rigidbody/collider in 2D.\", imports: [{ type: \"Collision2D\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerEnter\", parameters: \"other: Collider\", description: \"Called when the Collider other enters the trigger.\", imports: [{ type: \"Collider\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerExit\", parameters: \"other: Collider\", description: \"Called when the Collider other has stopped touching the trigger.\", imports: [{ type: \"Collider\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerStay\", parameters: \"other: Collider\", description: \"Called once per frame for every Collider other that is touching the trigger.\", imports: [{ type: \"Collider\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerEnter2D\", parameters: \"other: Collider2D\", description: \"Called when the Collider other enters the trigger in 2D.\", imports: [{ type: \"Collider2D\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerExit2D\", parameters: \"other: Collider2D\", description: \"Called when the Collider other has stopped touching the trigger in 2D.\", imports: [{ type: \"Collider2D\", module: \"UnityEngine\" }] },\n    { name: \"OnTriggerStay2D\", parameters: \"other: Collider2D\", description: \"Called once per frame for every Collider other that is touching the trigger in 2D.\", imports: [{ type: \"Collider2D\", module: \"UnityEngine\" }] },\n    { name: \"OnControllerColliderHit\", parameters: \"hit: ControllerColliderHit\", description: \"Called when the character controller hits a collider while performing a move.\", imports: [{ type: \"ControllerColliderHit\", module: \"UnityEngine\" }] },\n    { name: \"OnGUI\", parameters: \"\", description: \"Called for rendering and handling GUI events.\", imports: [] },\n    { name: \"OnMouseDown\", parameters: \"\", description: \"Called when the user has pressed the mouse button while over the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseDrag\", parameters: \"\", description: \"Called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.\", imports: [] },\n    { name: \"OnMouseUp\", parameters: \"\", description: \"Called when the user has released the mouse button.\", imports: [] },\n    { name: \"OnMouseEnter\", parameters: \"\", description: \"Called when the mouse enters the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseExit\", parameters: \"\", description: \"Called when the mouse is not any longer over the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseOver\", parameters: \"\", description: \"Called every frame while the mouse is over the GUIElement or Collider.\", imports: [] },\n    { name: \"OnMouseUpAsButton\", parameters: \"\", description: \"Called when the user has pressed the mouse button while over the GUIElement or Collider and is still holding down the mouse.\", imports: [] },\n    { name: \"OnApplicationFocus\", parameters: \"hasFocus: boolean\", description: \"Called when the application gains or loses focus.\", imports: [] },\n    { name: \"OnApplicationPause\", parameters: \"pauseStatus: boolean\", description: \"Called when the application is paused or resumed.\", imports: [] },\n    { name: \"OnApplicationQuit\", parameters: \"\", description: \"Called when the application is about to quit.\", imports: [] },\n    { name: \"OnPreRender\", parameters: \"\", description: \"Called before a camera starts rendering the scene.\", imports: [] },\n    { name: \"OnPostRender\", parameters: \"\", description: \"Called after a camera has finished rendering the scene.\", imports: [] },\n    { name: \"OnRenderImage\", parameters: \"source: RenderTexture, destination: RenderTexture\", description: \"Called after all rendering is complete to render image.\", imports: [{ type: \"RenderTexture\", module: \"UnityEngine\" }] },\n    { name: \"OnRenderObject\", parameters: \"\", description: \"Called after camera has rendered the scene.\", imports: [] },\n    { name: \"OnWillRenderObject\", parameters: \"\", description: \"Called once for each camera if the object is visible.\", imports: [] },\n    { name: \"OnPreCull\", parameters: \"\", description: \"Called before the camera culls the scene.\", imports: [] },\n    { name: \"OnAnimatorIK\", parameters: \"layerIndex: number\", description: \"Called right after the Animator has performed IK pass.\", imports: [] },\n    { name: \"OnAnimatorMove\", parameters: \"\", description: \"Called right after the Animator updates.\", imports: [] },\n    { name: \"OnDrawGizmos\", parameters: \"\", description: \"Called when the editor draws gizmos.\", imports: [] },\n    { name: \"OnValidate\", parameters: \"\", description: \"Called when the script is loaded or a value is changed in the inspector.\", imports: [] },\n    // Experience events\n    { name: \"OnExperiencePaused\", parameters: \"\", description: \"Called when the experience is paused.\", imports: [] },\n    { name: \"OnExperienceResumed\", parameters: \"\", description: \"Called when the experience is resumed.\", imports: [] },\n    { name: \"OnExperienceQuit\", parameters: \"\", description: \"Called when the experience is quit.\", imports: [] },\n];\n\nexport const ScriptableObjectAllowedMethods = [\n    \"Awake\",\n    \"OnEnable\",\n    \"OnDisable\",\n    \"OnDestroy\",\n    \"OnValidate\",\n    \"OnApplicationFocus\",\n    \"OnApplicationPause\",\n    \"OnApplicationQuit\",\n    \"OnExperiencePaused\",\n    \"OnExperienceResumed\",\n    \"OnExperienceQuit\"\n]\n","import {\n    ArrayLiteralExpression,\n    ClassDeclaration,\n    Decorator,\n    EnumDeclaration,\n    Expression, ImportDeclarationStructure,\n    NewExpression,\n    Node, OptionalKind, Project, PropertyAccessExpression,\n    PropertyDeclaration,\n    SourceFile, StringLiteral, StructureKind, Symbol, SymbolFlags,\n    SyntaxKind,\n    Type, TypeChecker, TypeFormatFlags, TypeReferenceNode, VariableDeclarationKind, VariableStatementStructure\n} from \"ts-morph\";\nimport * as path from 'path';\nimport {TransformationContext} from \"./transformers/TransformationContext\";\n\nconst propertyInfoCache = new Map<string, PropertyInfo[]>();\n\nexport let projectRoot: string = \"\";\nexport const GeniesDeclarationFileAnnotation = \"//@Genies-UnityApiInterface\";\nexport const GeniesInstancePropName = \"__geniesInstance__\";\nexport const MonobehaviourTypeName = \"MonoBehaviour\";\nexport const ScriptableObjectTypeName = \"ScriptableObject\";\nexport const NonSerializedDecorator = \"NonSerialized\";\nexport const SerializeFieldDecorator = \"SerializeField\";\n\nexport const GET_ITEM_NAME = \"get_Item\";\nexport const SET_ITEM_NAME = \"set_Item\";\n\nexport const componentMethods = new Set([\n    'GetComponent',\n    'TryGetComponent',\n    'GetComponentInChildren',\n    'GetComponentsInChildren',\n    'GetComponentInParent',\n    'GetComponentsInParent',\n    'GetComponents',\n    'AddComponent'\n]);\n\nexport enum GeniesScriptUiEvents {\n    None = 0,\n    PointerClick = 1 << 0, // 1\n    PointerDown = 1 << 1, // 2\n    PointerEnter = 1 << 2, // 4\n    PointerExit = 1 << 3, // 8\n    PointerUp = 1 << 4, // 16\n    BeginDrag = 1 << 5, // 32\n    Deselect = 1 << 6, // 64\n    Drag = 1 << 7, // 128\n    Drop = 1 << 8, // 256\n    EndDrag = 1 << 9, // 512\n    InitializePotentialDrag = 1 << 10, // 1024\n    Scroll = 1 << 11, // 2048\n    Select = 1 << 12, // 4096\n    Submit = 1 << 13, // 8192\n    UpdateSelected = 1 << 14, // 16384\n    Move = 1 << 15, // 32768\n    Cancel = 1 << 16 // 65536\n}\n\nexport const AllowedUiInterfaces = new Set([\n    'UnityEngine.EventSystems.IPointerClickHandler',\n    'UnityEngine.EventSystems.IPointerDownHandler',\n    'UnityEngine.EventSystems.IPointerEnterHandler',\n    'UnityEngine.EventSystems.IPointerExitHandler',\n    'UnityEngine.EventSystems.IPointerUpHandler',\n    'UnityEngine.EventSystems.IBeginDragHandler',\n    'UnityEngine.EventSystems.IDeselectHandler',\n    'UnityEngine.EventSystems.IDragHandler',\n    'UnityEngine.EventSystems.IDropHandler',\n    'UnityEngine.EventSystems.IEndDragHandler',\n    'UnityEngine.EventSystems.IInitializePotentialDragHandler',\n    'UnityEngine.EventSystems.IScrollHandler',\n    'UnityEngine.EventSystems.ISelectHandler',\n    'UnityEngine.EventSystems.ISubmitHandler',\n    'UnityEngine.EventSystems.IUpdateSelectedHandler',\n    'UnityEngine.EventSystems.IMoveHandler',\n    'UnityEngine.EventSystems.ICancelHandler',\n]);\n\nexport const UiInterfaceToEnumMap = new Map([\n    ['UnityEngine.EventSystems.IPointerClickHandler', GeniesScriptUiEvents.PointerClick],\n    ['UnityEngine.EventSystems.IPointerDownHandler', GeniesScriptUiEvents.PointerDown],\n    ['UnityEngine.EventSystems.IPointerEnterHandler', GeniesScriptUiEvents.PointerEnter],\n    ['UnityEngine.EventSystems.IPointerExitHandler', GeniesScriptUiEvents.PointerExit],\n    ['UnityEngine.EventSystems.IPointerUpHandler', GeniesScriptUiEvents.PointerUp],\n    ['UnityEngine.EventSystems.IBeginDragHandler', GeniesScriptUiEvents.BeginDrag],\n    ['UnityEngine.EventSystems.IDeselectHandler', GeniesScriptUiEvents.Deselect],\n    ['UnityEngine.EventSystems.IDragHandler', GeniesScriptUiEvents.Drag],\n    ['UnityEngine.EventSystems.IDropHandler', GeniesScriptUiEvents.Drop],\n    ['UnityEngine.EventSystems.IEndDragHandler', GeniesScriptUiEvents.EndDrag],\n    ['UnityEngine.EventSystems.IInitializePotentialDragHandler', GeniesScriptUiEvents.InitializePotentialDrag],\n    ['UnityEngine.EventSystems.IScrollHandler', GeniesScriptUiEvents.Scroll],\n    ['UnityEngine.EventSystems.ISelectHandler', GeniesScriptUiEvents.Select],\n    ['UnityEngine.EventSystems.ISubmitHandler', GeniesScriptUiEvents.Submit],\n    ['UnityEngine.EventSystems.IUpdateSelectedHandler', GeniesScriptUiEvents.UpdateSelected],\n    ['UnityEngine.EventSystems.IMoveHandler', GeniesScriptUiEvents.Move],\n    ['UnityEngine.EventSystems.ICancelHandler', GeniesScriptUiEvents.Cancel],\n]);\n\nconst AliasToTypeName: Map<string, string> = new Map([\n        [\"float\", \"Single\"],\n        [\"int\", \"Int32\"],\n        [\"double\", \"Double\"],\n        [\"long\", \"Int64\"],\n        [\"ulong\", \"UInt64\"],\n        [\"bool\", \"Boolean\"],\n        [\"string\", \"String\"],\n        [\"number\", \"Double\"],\n        [\"short\", \"Int16\"],\n        [\"ushort\", \"UInt16\"],\n        [\"byte\", \"Byte\"],\n        [\"sbyte\", \"SByte\"],\n        [\"uint\", \"UInt32\"],\n        [\"char\", \"Char\"],\n        [\"any\", \"Object\"]\n    ]\n)\n\nconst AliasToFullTypeName: Map<string, string> = new Map([\n        [\"float\", \"System.Single\"],\n        [\"int\", \"System.Int32\"],\n        [\"double\", \"System.Double\"],\n        [\"long\", \"System.Int64\"],\n        [\"ulong\", \"System.UInt64\"],\n        [\"bool\", \"System.Boolean\"],\n        [\"string\", \"System.String\"],\n        [\"number\", \"System.Double\"],\n        [\"short\", \"System.Int16\"],\n        [\"ushort\", \"System.UInt16\"],\n        [\"byte\", \"System.Byte\"],\n        [\"sbyte\", \"System.SByte\"],\n        [\"uint\", \"System.UInt32\"],\n        [\"char\", \"System.Char\"],\n        [\"any\", \"System.Object\"]\n    ]\n)\n\nexport const NumericalAliases = new Set([\n    \"byte\",\n    \"sbyte\",\n    \"short\",\n    \"ushort\",\n    \"int\",\n    \"uint\",\n    \"float\",\n    \"double\",\n    \"number\"\n])\n\nexport enum GeniesScriptType {\n    None = 0,\n    Monobehaviour = 1,\n    ScriptableObject = 2\n}\n\nexport interface PropertyInfo {\n    Path: string;\n    Name: string;\n    TypeName: string;\n    ChildProperties: PropertyInfo[];\n    IsArray: boolean;\n    IsEnum: boolean;\n    EnumKeys: string[];\n    EnumValues: string[];\n    Decorators: GeniesDecoratorInfo[];\n    IsGeniesBehaviourRef: boolean;\n    IsGeniesScriptableObjectRef: boolean;\n    Initializers: string[];\n    ArrayElementInitializer: PropertyInfo | undefined;\n    ArrayDimension: number;\n}\n\nexport interface GeniesDecoratorInfo {\n    Type: string;\n    Args: string[];\n}\n\nexport interface FileCompileOutput {\n    FilePath: string;\n    IsSuccessful: boolean;\n    Errors?: string[];\n    BaseTypes?: string[];\n    JsSource: string;\n    IsScriptableObj: boolean;\n    IsMonobehaviour: boolean;\n    Properties: PropertyInfo[];\n    Id: string;\n    DefaultTypeName: string;\n    InheritanceChain: string[];\n    SupportedUiEvents: GeniesScriptUiEvents;\n    ReferencedSpecifiers?: string[];\n}\n\n/**\n * Sets the project root path for other utilities to consume.\n */\nexport function setProjectRoot(root: string) {\n    projectRoot = root;\n}\n\nexport function extendsMonoBehaviour(classDecl: ClassDeclaration): boolean {\n    let baseClass = classDecl.getBaseClass();\n    while (baseClass) {\n        if (baseClass.getName() === \"MonoBehaviour\") {\n            return true;\n        }\n        baseClass = baseClass.getBaseClass();\n    }\n    return false;\n}\n\nexport function extendsScriptableObject(classDecl: ClassDeclaration): boolean {\n    let baseClass = classDecl.getBaseClass();\n    while (baseClass) {\n        if (baseClass.getName() === \"ScriptableObject\") {\n            return true;\n        }\n        baseClass = baseClass.getBaseClass();\n    }\n    return false;\n}\n\nexport function removeDecorators(sourceFile: SourceFile, decorators: Decorator[]) {\n\n    // Start from the end so we don't mess up positions as we remove content\n    const positions = decorators\n        .map(decorator => {\n            const start = decorator.getFullStart();\n            let end = decorator.getEnd();\n\n            return { start, end };\n        })\n        .sort((a, b) => b.start - a.start); // Sort in reverse order\n\n    // Remove each decorator and its associated comments\n    for (const { start, end } of positions) {\n        \n        sourceFile.replaceText([start, end], '');\n    }\n}\n\nexport interface NodeWithDepth {\n    node: Node;\n    depth: number;\n}\n\nexport function collectNodes(node: Node, depth = 0, nodes: NodeWithDepth[] = []): NodeWithDepth[] {\n    console.log(node);\n    node.forEachChild(child => collectNodes(child, depth + 1, nodes));\n    nodes.push({ node, depth });\n    return nodes;\n}\n\nexport function traversePostOrder(node: Node, callback: (node: Node) => void): void {\n    node.forEachChild(child => traversePostOrder(child, callback));\n    callback(node);\n}\n\n/**\n * Traverses the full prototype chain of a class, including base classes and implemented interfaces.\n * @param classDeclaration The ClassDeclaration to traverse.\n * @returns The PrototypeChain containing all base classes and interfaces.\n */\nexport function traversePrototypeChain(classDeclaration: ClassDeclaration): string[] {\n    const resultSet: Set<string> = new Set(); // To store unique type names\n\n    let currentClass: ClassDeclaration | undefined = classDeclaration;\n\n    while (currentClass) {\n        // Add the current class's full type name\n        const classTypeName = getFullTypeName(currentClass.getType());\n        if (classTypeName) {\n            resultSet.add(classTypeName);\n        }\n\n        // Process all implemented interfaces\n        const implementedInterfaces = currentClass.getImplements();\n\n        implementedInterfaces.forEach(implementClause => {\n            const ifaceType = implementClause.getType();\n\n            // Initialize queue with the current interface type\n            const queue: Type[] = [ifaceType];\n\n            while (queue.length > 0) {\n                const currentIfaceType = queue.shift();\n                if (!currentIfaceType) {\n                    continue;\n                }\n\n                const ifaceName = getFullTypeName(currentIfaceType);\n                if (!ifaceName || resultSet.has(ifaceName)) {\n                    continue; // Skip if already processed or name is invalid\n                }\n\n                resultSet.add(ifaceName);\n\n                // Enqueue extended interfaces\n                const baseTypes = currentIfaceType.getBaseTypes();\n                baseTypes.forEach(baseType => {\n                    queue.push(baseType);\n                });\n            }\n        });\n\n        // Move to the base class, if any\n        currentClass = currentClass.getBaseClass();\n    }\n\n    return Array.from(resultSet);\n}\n\n\nexport function isSignalBusType(type: Type): boolean {\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n    const name = symbol.getName();\n    return name === \"SignalBus\";\n}\n\nexport function isGeniesEventType(type: Type): boolean {\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n    const name = symbol.getName();\n\n    return name === \"GeniesEvent\";\n}\n\n\nexport function isOrInheritsFromObject(type: Type, typeChecker: TypeChecker): boolean {\n    if (!type) return false;\n\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n\n    if (['Object'].includes(symbol.getName())) {\n        return true;\n    }\n\n    return inheritsFrom(type, ['Object'], typeChecker);\n}\n\nexport function typesAreEqual(type1: Type, type2: Type): boolean {\n\n    if (type1 === type2) {\n        return true;\n    }\n\n    const type1Text = cleanTypeText(type1.getText());\n    const type2Text = cleanTypeText(type2.getText());\n    return type1Text === type2Text;\n}\n\n/*\n * Does nominal check if a type is assignable to another.\n */\nexport function isTypeAssignableTo(type: Type, inheritedType: Type, typeChecker: TypeChecker) {\n\n    if (typesAreEqual(type, inheritedType)) {\n        return true;\n    }\n\n    const baseTypes = getBaseTypes(type, typeChecker);\n    const foundType = baseTypes.find(b => typesAreEqual(b, inheritedType))\n\n    return foundType !== undefined;\n\n}\n\nexport function isOrInheritsFromGameObjectOrComponent(type: Type, typeChecker: TypeChecker): boolean {\n    if (!type) return false;\n\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n\n    if (['GameObject', 'Component', 'MonoBehaviour'].includes(symbol.getName())) {\n        return true;\n    }\n\n    return inheritsFrom(type, ['GameObject', 'Component', 'MonoBehaviour'], typeChecker);\n}\n\nexport function inheritsFrom(type: Type, baseNames: string[], typeChecker: TypeChecker): boolean {\n    const baseTypes = getBaseTypes(type, typeChecker);\n    for (const baseType of baseTypes) {\n        const baseTypeName = baseType.getSymbol()?.getName();\n        if (baseTypeName && baseNames.includes(baseTypeName)) {\n            return true;\n        }\n        if (inheritsFrom(baseType, baseNames, typeChecker)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function getBaseTypes(type: Type, typeChecker: TypeChecker, visited = new Set<Type>()): Type[] {\n    const baseTypes: Type[] = [];\n    const symbol = type.getSymbol();\n    if (!symbol) return baseTypes;\n\n    const declarations = symbol.getDeclarations();\n    if (!declarations) return baseTypes;\n\n    for (const declaration of declarations) {\n        if (Node.isClassDeclaration(declaration)) {\n            const heritageClauses = declaration.getHeritageClauses();\n            for (const heritageClause of heritageClauses) {\n                const typeNodes = heritageClause.getTypeNodes();\n                for (const typeNode of typeNodes) {\n                    const baseType = typeChecker.getTypeAtLocation(typeNode);\n                    if (baseType && !visited.has(baseType)) {\n                        visited.add(baseType);\n                        baseTypes.push(baseType);\n                        // Recursively add base types from the current base type\n                        baseTypes.push(...getBaseTypes(baseType, typeChecker, visited));\n                    }\n                }\n            }\n        }\n    }\n    return baseTypes;\n}\n\n\nfunction extractEnumDetails(type: Type): {\n    keys: string[];\n    values: (string | number | undefined)[];\n} {\n    const symbol = type.getSymbol();\n    const declaration = symbol?.getDeclarations().find(dec => dec.getKind() === SyntaxKind.EnumDeclaration) as EnumDeclaration;\n    if (declaration) {\n        return {\n            keys: declaration.getMembers().map(member => member.getName()),\n            values: declaration.getMembers().map(member => member.getValue()) // assuming numeric or const enums\n        };\n    }\n    return {keys: [], values: []};\n}\n\nexport function sortImportsAndVars(sourceFile: SourceFile) {\n    // Get all top-level statements\n    const allStatements = sourceFile.getStatements();\n\n    // Separate import declarations, variable statements, and others.\n    const importDeclarations = allStatements.filter(stmt =>\n        stmt.getKind() === SyntaxKind.ImportDeclaration\n    );\n    const variableStatements = allStatements.filter(stmt =>\n        stmt.getKind() === SyntaxKind.VariableStatement\n    );\n    const otherStatements = allStatements.filter(stmt =>\n        stmt.getKind() !== SyntaxKind.ImportDeclaration &&\n        stmt.getKind() !== SyntaxKind.VariableStatement\n    );\n\n    // Reconstruct the source file text:\n    // 1. All sorted import declarations.\n    // 2. Then a blank line.\n    // 3. Then all sorted variable statements.\n    // 4. Then a blank line.\n    // 5. Finally, the rest of the statements.\n    const newText = [\n        ...importDeclarations.map(stmt => stmt.getText()),\n        \"\",\n        ...variableStatements.map(stmt => stmt.getText()),\n        \"\",\n        ...otherStatements.map(stmt => stmt.getText())\n    ].join(\"\\n\\n\");\n\n    // Replace the source file's text with the new text.\n    sourceFile.replaceWithText(newText);\n}\n\n\n// -----------------------------------------------------\n//  HELPER: Create `$generic(...)` variable if not exist\n// -----------------------------------------------------\nexport function createGenericTypeVariable(\n    type: Type,\n    typeArguments: Type[],\n    sourceFile: SourceFile,\n    transformationContext: TransformationContext\n): string {\n    if (!transformationContext.sourceFileGenericTypeMap.has(sourceFile)) {\n        transformationContext.sourceFileGenericTypeMap.set(sourceFile, new Map());\n    }\n\n    const genericMap = transformationContext.sourceFileGenericTypeMap.get(sourceFile)!;\n    const genericKey = getGenericTypeKey(type, typeArguments);\n    if (!genericMap.has(genericKey)) {\n\n        const genericTypeName = getTypeName(type);\n        const genericArgs = typeArguments.map(t => {\n            return getTypeArgNameAndEnsureImported(\n                t,\n                sourceFile,\n                transformationContext\n            );\n        });\n\n        const genericDeclaration = `// @ts-ignore \\n $generic(${genericTypeName}, ${genericArgs.join(\", \")})`;\n        const genericVarName = `_${genericKey.replace(/\\$/g, \"_\")}`;\n\n        genericMap.set(genericKey, genericVarName);\n\n        // Insert new statements\n        sourceFile.addVariableStatement(\n            {\n                declarationKind: VariableDeclarationKind.Const,\n                declarations: [{\n                    name: genericVarName,\n                    initializer: genericDeclaration\n                }]\n            });\n    }\n\n\n    return genericMap.get(genericKey)!;\n}\n\n// -----------------------------------------------------\n//  HELPER: Recursively get a stable \"key\" for type+args\n// -----------------------------------------------------\nexport function getGenericTypeKey(type: Type, typeArguments: Type[]): string {\n    const baseName = getTypeName(type);\n    const nested = typeArguments.map(t => {\n        const tArgs = t.getTypeArguments();\n        return (tArgs.length > 0) ? getGenericTypeKey(t, tArgs) : getTypeName(t);\n    }).join(\"$\");\n    return `${baseName}$${nested}`;\n}\n\nexport function getTypeName(type: Type): string {\n    return type.getSymbol()?.getName() ?? type.getText();\n}\n\n// -----------------------------------------------------\n//  HELPER: If type has nested generics, create them too\n// -----------------------------------------------------\nfunction getTypeArgNameAndEnsureImported(\n    type: Type,\n    sourceFile: SourceFile,\n    transformationContext: TransformationContext\n): string {\n    if (type.getTypeArguments().length > 0) {\n        return createGenericTypeVariable(\n            type,\n            type.getTypeArguments(),\n            sourceFile,\n            transformationContext\n        );\n    }\n\n    return getTypeNameAndEnsureImported(type, sourceFile);\n}\n\n\nexport function getTypeNameAndEnsureImported(type: Type, sourceFile: SourceFile): string {\n\n    let typeName = getTypeName(type);\n    let csTypeName = \"\";\n    let typeModule = \"\";\n\n    if (AliasToTypeName.has(typeName)) {\n        let current = typeName;\n        typeName = AliasToTypeName.get(current) as string;\n        typeModule = \"System\";\n    } else {\n        const scriptType = getGeniesScriptTypeFromType(type);\n        if (scriptType !== GeniesScriptType.None) {\n            switch (scriptType) {\n                case GeniesScriptType.Monobehaviour:\n                    typeName = \"MonoBehaviour\";\n                    typeModule = \"UnityEngine\";\n                    break;\n                case GeniesScriptType.ScriptableObject:\n                    typeName = \"ScriptableObject\";\n                    typeModule = \"UnityEngine\";\n                    break;\n            }\n        } else if (!getIsUnityAPIType(type)) {\n            throw new Error(\"Can't use non CSharp types\");\n        } else {\n            csTypeName = getFullTypeName(type, true, false);\n            const lastDotIndex = csTypeName.lastIndexOf(\".\");\n            typeModule = csTypeName.substring(0, lastDotIndex);\n        }\n    }\n\n    // Check if the type's module is already imported\n    const existingImport = sourceFile.getImportDeclarations().find(importDecl => {\n        return importDecl.getModuleSpecifierValue() === typeModule;\n    });\n\n    if (!existingImport) {\n        // Add the import if it's not already imported\n        const importStructure: ImportDeclarationStructure = {\n            kind: StructureKind.ImportDeclaration,\n            moduleSpecifier: typeModule,\n            namedImports: [{name: typeName}],\n        };\n        sourceFile.addImportDeclaration(importStructure);\n    } else {\n        // If the module is imported but the type is not included, add the named import\n        const namedImports = existingImport.getNamedImports();\n        if (!namedImports.some(namedImport => namedImport.getName() === typeName)) {\n            existingImport.addNamedImport(typeName);\n        }\n    }\n\n    // Return the $typeof conversion string\n    return typeName;\n}\n\nexport function getFullTypeName(type: Type, forCsharp: boolean = true, includeArguments: boolean = true): string {\n    let text = \"\";\n\n    const aliasSymbol = type.getAliasSymbol();\n    if (aliasSymbol) {\n        text = aliasSymbol.getName();\n    } else {\n        text = type.getText();\n    }\n\n    if (AliasToFullTypeName.has(text)) {\n        return AliasToFullTypeName.get(text) as string;\n    }\n\n    const symbol = type.getSymbol();\n    if (!symbol) {\n        return text; // Return the simple type text if no symbol is available\n    }\n\n    if (!getIsUnityAPIType(type)) {\n        const declarations = symbol.getDeclarations();\n        let isExported = false;\n\n        declarations.forEach(decl => {\n            if (Node.isInterfaceDeclaration(decl) || Node.isClassDeclaration(decl)) {\n                isExported = decl.isExported();\n            }\n        });\n\n        if (!isExported && declarations.length > 0) {\n            const sourceFile = declarations[0].getSourceFile();\n            const sourceFilePath = sourceFile.getFilePath();\n            const relativePath = convertToAliasPath(projectRoot, sourceFilePath);\n            const parsedPath = path.parse(relativePath);\n            const filePathWithoutExt = path.join(parsedPath.dir, parsedPath.name);\n\n            text = `${filePathWithoutExt}.${symbol.getFullyQualifiedName().replace(/['\"]/g, \"\")}`;\n        } else {\n            text = symbol.getFullyQualifiedName().replace(/['\"]/g, \"\");\n        }\n\n        const parsed = path.parse(text);\n        // If 'dir' isnt empty, it suggests that text includes some slash-like separator\n        const isPath = parsed.dir !== \"\" || parsed.root !== \"\";\n        if (isPath) {\n            let aliasPath = convertToGeniesAliasPath(text);\n\n            if (aliasPath != null) {\n                text = aliasPath;\n            }\n        }\n\n    } else {\n        text = symbol.getFullyQualifiedName().replace(/['\"]/g, \"\");\n    }\n\n    const regex = /\\$(\\d+)$/;\n    if (forCsharp && regex.test(text)) {\n        // Extract the number after $ and convert to backtick notation\n        text = text.replace(regex, (match, number) => {\n            return \"`\" + number;\n        });\n\n        if (includeArguments) {\n            const typeArguments = type.getTypeArguments();\n            if (typeArguments.length > 0) {\n                text += '<';\n                typeArguments.forEach((arg, index) => {\n                    let argText = getFullTypeName(arg);\n                    text += argText;\n                    if (index < typeArguments.length - 1) {\n                        text += ', ';\n                    }\n                });\n                text += '>';\n            }\n        }\n    }\n\n    return text;\n}\n\n\n// Helper function to update paths for child properties\nfunction updateChildPaths(childProperties: PropertyInfo[], parentPath: string): PropertyInfo[] {\n    return childProperties.map(childProp => {\n        // Create a deep copy to avoid modifying cached objects\n        const updatedChildProp = { ...childProp };\n\n        // Use the existing Name property directly\n        updatedChildProp.Path = `${parentPath}.${childProp.Name}`;\n\n        // Recursive update for nested children\n        if (updatedChildProp.ChildProperties && updatedChildProp.ChildProperties.length > 0) {\n            updatedChildProp.ChildProperties = updateChildPaths(updatedChildProp.ChildProperties, updatedChildProp.Path);\n        }\n\n        return updatedChildProp;\n    });\n}\n\nexport function extractProperties(cls: ClassDeclaration, basePath: string = '', typeArgumentMap: Map<string, Type> = new Map()): PropertyInfo[] {\n\n    const className = cls.getName() || '';\n    const sourceFilePath = cls.getSourceFile().getFilePath();\n    \n    const typeParams = cls.getTypeParameters().map(p => p.getName()).join(',');\n    const typeArgs = Array.from(typeArgumentMap.entries())\n        .map(([key, value]) => {\n            \n            let typeName = \"\";\n            const genericArgs = value.getTypeArguments();\n            if(genericArgs?.length > 0)\n            {\n                typeName = getGenericTypeKey(value, genericArgs);\n            }\n            else\n            {\n                typeName = getFullTypeName(value);\n            }\n            \n            return `${key}:${typeName}`\n        })\n        .join(',');\n    const cacheKey = `${sourceFilePath}|${className}|${typeParams}|${typeArgs}`;\n\n    // Check if we have this class in our cache\n    if (propertyInfoCache.has(cacheKey)) {\n        // Get the cached properties but update their paths with the current basePath\n        const cachedProperties = propertyInfoCache.get(cacheKey)!;\n        if (basePath) {\n            return cachedProperties.map(prop => {\n                // Create a deep copy of the property to avoid modifying the cached version\n                const updatedProp = { ...prop };\n\n                // Update the path with the current basePath using the Name property\n                updatedProp.Path = basePath ? `${basePath}.${prop.Name}` : prop.Name;\n\n                // Also update child properties recursively\n                if (updatedProp.ChildProperties && updatedProp.ChildProperties.length > 0) {\n                    updatedProp.ChildProperties = updateChildPaths(updatedProp.ChildProperties, updatedProp.Path);\n                }\n\n                return updatedProp;\n            });\n        }\n        return cachedProperties;\n    }\n\n    const properties: PropertyInfo[] = [];\n    cls.getProperties().forEach(prop => {\n        const visibility = prop.getScope();\n        const decorators = extractDecorators(prop);\n\n        // Skip static or readonly properties\n        if (prop.isStatic() || prop.isReadonly()) {\n            return;\n        }\n\n        if (visibility === 'private' && !decorators.some(d => d.Type === SerializeFieldDecorator)) {\n            return;\n        }\n\n        if (visibility === 'public' && decorators.some(d => d.Type === NonSerializedDecorator)) {\n            return;\n        }\n\n        const type = resolveGenericType(prop.getType(), typeArgumentMap);\n        const isArray = type.isArray();\n\n        const resolvedType = resolveArrayElementType(type, typeArgumentMap);\n        const typeName = getFullTypeName(resolvedType);\n        const propName = prop.getName();\n        let fullPath = basePath ? `${basePath}.${propName}` : propName;\n\n        function getInitializer(expression: Expression): string {\n            if (expression.getKind() === SyntaxKind.NewExpression) {\n                const newExpression = expression as NewExpression;\n                const type = newExpression.getType();\n                const fullTypeName = getFullTypeName(type);\n\n                // Extract the arguments of the new expression\n                const args = newExpression.getArguments().map(arg => arg.getText()).join(\", \");\n                return `new ${fullTypeName}(${args});`;\n            } else if (expression.getKind() === SyntaxKind.PropertyAccessExpression) {\n                // Handle something like \"Vector3.forward\"\n                const pae = expression as PropertyAccessExpression;\n\n                // The left side should be something like \"Vector3\"\n                const leftExpr = pae.getExpression();\n                const leftType = leftExpr.getType();\n\n                const leftFullTypeName = getFullTypeName(leftType);\n\n                // The right side (the actual property), e.g. \"forward\"\n                const memberName = pae.getName();\n\n                // Return e.g. \"UnityEngine.Vector3.forward\"\n                return `${leftFullTypeName}.${memberName}`;\n\n            } else {\n                if (expression.getKind() === SyntaxKind.StringLiteral) {\n                    const stringLiteral = expression as StringLiteral;\n                    return stringLiteral.getLiteralValue();\n                } else {\n                    // For other types, just return the raw text\n                    return expression.getText();\n                }\n            }\n        }\n\n        const initializerExpressions: string[] = [];\n        if (prop.hasInitializer()) {\n            const initializer = prop.getInitializer();\n            if (initializer) {\n                if (initializer.getKind() === SyntaxKind.ArrayLiteralExpression) {\n                    const arrayLiteral = initializer as ArrayLiteralExpression;\n                    for (let i = 0; i < arrayLiteral.getElements().length; i++) {\n                        const element = arrayLiteral.getElements()[i];\n                        initializerExpressions.push(getInitializer(element));\n                    }\n                } else {\n                    initializerExpressions.push(getInitializer(initializer));\n                }\n            }\n        }\n\n        const propertyInfo: PropertyInfo = {\n            Path: fullPath,\n            Name: propName,\n            TypeName: typeName,\n            ChildProperties: [],\n            IsArray: isArray,\n            IsEnum: false,\n            EnumKeys: [],\n            EnumValues: [],\n            Decorators: extractDecorators(prop),\n            IsGeniesBehaviourRef: false,\n            IsGeniesScriptableObjectRef: false,\n            Initializers: initializerExpressions,\n            ArrayElementInitializer: undefined,\n            ArrayDimension: -1,\n        };\n\n        if (isArray) {\n            let dimension = 1;\n            propertyInfo.ArrayElementInitializer = getArrayElementInitializer(type, typeName, propName, fullPath, dimension, typeArgumentMap);\n            propertyInfo.ArrayDimension = dimension;\n            properties.push(propertyInfo);\n            return;\n        }\n\n        fillExtraPropertyInfo(resolvedType, propertyInfo, typeArgumentMap);\n        properties.push(propertyInfo);\n    });\n\n    propertyInfoCache.set(cacheKey, properties);\n\n    return properties;\n}\n\nfunction fillExtraPropertyInfo(resolvedType: Type, propertyInfo: PropertyInfo, typeArgumentMap: Map<string, Type>) {\n    const isEnum = resolvedType.isEnum();\n    const symbol = resolvedType.getSymbol() || resolvedType.getAliasSymbol();\n\n    if (!symbol) {\n        return;\n    }\n\n    const declarations = symbol.getDeclarations();\n    const declaration = declarations[0];\n    const isUnityType = getIsUnityAPIDeclaration(declaration);\n    const geniesScriptType = getGeniesScriptTypeFromNode(declaration, isUnityType);\n\n    propertyInfo.IsGeniesBehaviourRef = geniesScriptType == GeniesScriptType.Monobehaviour;\n    propertyInfo.IsGeniesScriptableObjectRef = geniesScriptType == GeniesScriptType.ScriptableObject;\n\n    if (isUnityType || geniesScriptType !== GeniesScriptType.None) {\n        return;\n    }\n\n    if (isEnum) {\n        fillEnumInfo(propertyInfo, resolvedType);\n    }\n\n    if (symbol.getDeclarations().some(declaration => Node.isClassDeclaration(declaration))) {\n        const classDecl = symbol.getDeclarations().find(Node.isClassDeclaration) as ClassDeclaration;\n        const typeParams = classDecl.getTypeParameters();\n        const typeArgs = resolvedType.getTypeArguments();\n\n        typeParams.forEach((param, index) => {\n            const paramName = param.getName();\n            const uniqueParamName = `${paramName}_${classDecl.getName()}`; // Ensure uniqueness by appending the class name\n            typeArgumentMap.set(uniqueParamName, typeArgs[index]);\n        });\n\n        //Get base type args\n        typeArgumentMap = getCompleteTypeArgumentMap(classDecl, typeArgumentMap);\n\n        //Collect properties\n        const childProperties: PropertyInfo[] = [];\n        let baseClass = classDecl;\n        while (baseClass) {\n            childProperties.unshift(...extractProperties(baseClass, propertyInfo.Path, typeArgumentMap));\n\n            let newBase = baseClass.getBaseClass();\n            if (newBase !== undefined) {\n                baseClass = newBase;\n            } else {\n                break;\n            }\n        }\n\n        propertyInfo.ChildProperties = childProperties;\n    }\n}\n\nfunction fillEnumInfo(propertyInfo: PropertyInfo, resolvedType: Type) {\n    const {keys, values} = extractEnumDetails(resolvedType);\n    propertyInfo.EnumKeys = keys;\n    propertyInfo.EnumValues = values.map(value => value === undefined ? \"\" : value.toString());\n    propertyInfo.IsEnum = true;\n}\n\nfunction getArrayElementInitializer(type: Type, underlyingTypeName: string, propName: string, propPath: string, dimension: number, typeArgumentMap: Map<string, Type>): PropertyInfo {\n    let resolvedType = type.isArray() ? type.getArrayElementType()! : type;\n\n    // Ensure proper resolution of generic type arguments and array elements\n    if (!resolvedType.isArray()) {\n        resolvedType = resolveArrayElementType(resolvedType, typeArgumentMap);\n    }\n\n    let currentDimension = dimension;\n\n    const propertyInfo: PropertyInfo = {\n        Path: propPath + \"_D\" + dimension,\n        Name: propName,\n        TypeName: underlyingTypeName,\n        ArrayDimension: dimension,\n        ChildProperties: [],\n        IsArray: resolvedType.isArray(),\n        IsEnum: resolvedType.isEnum(),\n        EnumKeys: [],\n        EnumValues: [],\n        Decorators: [],\n        IsGeniesBehaviourRef: false,\n        IsGeniesScriptableObjectRef: false,\n        Initializers: [],\n        ArrayElementInitializer: undefined\n    };\n\n    if (!resolvedType.isArray()) {\n        fillExtraPropertyInfo(resolvedType, propertyInfo, typeArgumentMap);\n    } else {\n        propertyInfo.ArrayElementInitializer = getArrayElementInitializer(resolvedType, underlyingTypeName, propName, propPath, ++currentDimension, typeArgumentMap);\n    }\n\n    return propertyInfo;\n}\n\n/**\n * Builds a complete type argument map that includes inherited type parameters from base classes\n */\nexport function getCompleteTypeArgumentMap(cls: ClassDeclaration, existingTypeArgumentMap: Map<string, Type>): Map<string, Type> {\n    // Process the inheritance chain from the current class up\n    processInheritanceChain(cls, existingTypeArgumentMap);\n\n    return existingTypeArgumentMap;\n}\n/**\n * Processes the inheritance chain to build a complete type argument map\n */\nfunction processInheritanceChain(cls: ClassDeclaration, typeArgumentMap: Map<string, Type>): void {\n    const baseClass = cls.getBaseClass();\n    if (!baseClass) {\n        return;\n    }\n\n    // Get the heritage clause that extends the base class\n    const heritageClause = cls.getHeritageClauseByKind(SyntaxKind.ExtendsKeyword);\n    if (!heritageClause) {\n        return;\n    }\n\n    const typeNodes = heritageClause.getTypeNodes();\n    if (typeNodes.length === 0) {\n        return;\n    }\n\n    const extendsTypeNode = typeNodes[0];\n    const baseTypeArgs = extendsTypeNode.getTypeArguments();\n    const baseTypeParams = baseClass.getTypeParameters();\n\n    // Get the actual Type that represents the base class with applied type arguments\n    const baseType = cls.getBaseTypes()[0];\n    if (baseType) {\n        // Get resolved type arguments from the Type object directly\n        const resolvedTypeArgs = baseType.getTypeArguments();\n\n        // For each type parameter in the base class\n        baseTypeParams.forEach((param, index) => {\n            if (index < resolvedTypeArgs.length) {\n                const baseParamName = param.getName();\n                const baseClassName = baseClass.getName() || '';\n                const uniqueBaseParamName = `${baseParamName}_${baseClassName}`;\n\n                // Add the resolved type argument to our map\n                typeArgumentMap.set(uniqueBaseParamName, resolvedTypeArgs[index]);\n\n                // Check if this type is itself a reference to another generic parameter\n                const typeArg = resolvedTypeArgs[index];\n                if (typeArg.isTypeParameter()) {\n                    // This is a type parameter being passed through, so we need to check\n                    // if we have a concrete type for it in our map\n                    const symbol = typeArg.getSymbol();\n                    if (symbol) {\n                        const declarations = symbol.getDeclarations();\n                        if (declarations && declarations.length > 0) {\n                            const declaration = declarations[0];\n                            if (Node.isTypeParameterDeclaration(declaration)) {\n                                const parent = declaration.getParent();\n                                if (Node.isClassDeclaration(parent) || Node.isInterfaceDeclaration(parent)) {\n                                    const parentName = parent.getName() || '';\n                                    const paramName = symbol.getName();\n                                    const uniqueParamName = `${paramName}_${parentName}`;\n\n                                    if (typeArgumentMap.has(uniqueParamName)) {\n                                        // Map the base class parameter to the concrete type\n                                        typeArgumentMap.set(uniqueBaseParamName, typeArgumentMap.get(uniqueParamName)!);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    // Fallback approach remains as a safety measure\n    else if (baseTypeArgs.length > 0) {\n        // For each type parameter in the base class\n        baseTypeParams.forEach((param, index) => {\n            if (index >= baseTypeArgs.length) {\n                return;\n            }\n\n            const baseParamName = param.getName();\n            const baseClassName = baseClass.getName() || '';\n            const uniqueBaseParamName = `${baseParamName}_${baseClassName}`;\n\n            // Get the corresponding type argument passed to the base class\n            const typeArgNode = baseTypeArgs[index];\n\n            // If the type argument is a type reference (could be a type parameter from the derived class)\n            if (typeArgNode.getKind() === SyntaxKind.TypeReference) {\n                const typeRef = typeArgNode as TypeReferenceNode;\n                const typeName = typeRef.getTypeName();\n\n                if (Node.isIdentifier(typeName)) {\n                    const derivedTypeParamName = typeName.getText();\n                    const className = cls.getName() || '';\n                    const uniqueDerivedParamName = `${derivedTypeParamName}_${className}`;\n\n                    // If this is a reference to a type parameter from the derived class\n                    // and we have a concrete type for it in our map\n                    if (typeArgumentMap.has(uniqueDerivedParamName)) {\n                        // Map the base class parameter to the same concrete type\n                        typeArgumentMap.set(uniqueBaseParamName, typeArgumentMap.get(uniqueDerivedParamName)!);\n                    }\n                }\n            }\n            // For any other type argument (concrete type)\n            else {\n                // Get the type of the node and add it to our map\n                const typeArg = typeArgNode.getType();\n                typeArgumentMap.set(uniqueBaseParamName, typeArg);\n            }\n        });\n    }\n\n    // Continue processing the inheritance chain recursively\n    processInheritanceChain(baseClass, typeArgumentMap);\n}\n\nfunction resolveGenericType(type: Type, typeArgumentMap: Map<string, Type>): Type {\n    let resolvedType = type;\n\n    if (resolvedType.isTypeParameter()) {\n        const typeName = resolvedType.getSymbol()?.getName();\n        const parentDecl = resolvedType.getSymbol()?.getDeclarations()[0].getParent();\n        const declaringClassName = parentDecl && Node.isClassDeclaration(parentDecl) ? parentDecl.getName() : '';\n        const uniqueTypeName = `${typeName}_${declaringClassName}`; // Ensure uniqueness by appending the class name\n        if (uniqueTypeName && typeArgumentMap.has(uniqueTypeName)) {\n            resolvedType = typeArgumentMap.get(uniqueTypeName)!;\n        }\n    }\n\n    return resolvedType;\n}\n\nfunction resolveArrayElementType(type: Type, typeArgumentMap: Map<string, Type>): Type {\n    let resolvedType = type;\n\n    while (resolvedType?.isArray()) {\n        resolvedType = resolvedType.getArrayElementType()!;\n    }\n\n    resolvedType = resolveGenericType(resolvedType, typeArgumentMap);\n\n    return resolvedType;\n}\n\nfunction getIsUnityAPISourceFile(sourceFile: SourceFile) {\n    if (!sourceFile) {\n        return false;\n    }\n\n    const firstNode = sourceFile.getFirstChild();\n\n    if (!firstNode) {\n        console.log(\"No nodes found in the file.\");\n        return false;\n    }\n\n    const leadingComments = firstNode.getLeadingCommentRanges();\n    return leadingComments.length > 0 && leadingComments[0].getText() === GeniesDeclarationFileAnnotation;\n}\n\nexport function getIsValidUnityGenericTypeArg(argType: Type): boolean | undefined {\n    // Check if it's a type parameter (like T in your example)\n    if (argType.isTypeParameter()) {\n        // Get the constraint directly from the type\n        const constraint = argType.getConstraint();\n\n        // If it has a constraint, check if the constraint is a valid Unity type\n        if (constraint) {\n            return getIsValidUnityGenericTypeArg(constraint);\n        }\n\n        return false; // Type parameter with no constraint\n    }\n\n    // Original checks for non-type parameter types\n    let text = \"\";\n    const aliasSymbol = argType.getAliasSymbol();\n    if (aliasSymbol) {\n        text = aliasSymbol.getName();\n    } else {\n        text = argType.getText();\n    }\n\n    if (AliasToTypeName.has(text)) {\n        return true;\n    }\n\n    const scriptType = getGeniesScriptTypeFromType(argType);\n    if (scriptType !== GeniesScriptType.None) {\n        return true;\n    }\n\n    return getIsUnityAPIType(argType);\n}\n\nexport function isUserDefinedType(type: Type): boolean {\n    const symbol = type.getSymbol();\n    if (!symbol) return false;\n\n    // Get all declarations for the type's symbol.\n    const declarations = symbol.getDeclarations();\n\n    // If any declaration comes from a non-external source file, treat it as user defined.\n    return declarations.some(declaration => {\n        const sourceFile = declaration.getSourceFile();\n        const isClassOrInterface = Node.isClassLikeDeclarationBase(declaration) || Node.isInterfaceDeclaration(declaration);\n        return isClassOrInterface && !sourceFile.isFromExternalLibrary() && !sourceFile.isDeclarationFile();\n    });\n}\n\nexport function getIsUnityAPIType(type: Type) {\n    // Try to get the primary symbol\n    let symbol = type.getSymbol();\n    \n    // If it's missing, try the alias symbol (for types like aliases, etc.)\n    if (!symbol) {\n        return false;\n    }\n\n    const declarations = symbol.getDeclarations();\n    if (!declarations || declarations.length === 0) {\n        return false;\n    }\n\n    const sourceFile = declarations[0].getSourceFile();\n    return getIsUnityAPISourceFile(sourceFile);\n}\n\nexport function getTypeByName(typeName: string, typeChecker: TypeChecker): Type | undefined {\n    // Resolve the symbol for the type name in the global scope\n    const symbol = typeChecker.resolveName(typeName, undefined, SymbolFlags.All, false);\n\n    if (!symbol) {\n        console.log(`Global type '${typeName}' not found.`);\n        return undefined;\n    }\n\n    // Get the type from the symbol\n    const type = typeChecker.getDeclaredTypeOfSymbol(symbol);\n\n    return type;\n}\n\nexport function cleanTypeText(typeText: string): string {\n    // Remove branding and extra spaces\n    return typeText.replace(/&\\s*\\{[^}]*\\}/, '').trim();\n}\n\nexport function isAssignmentToSymbol(node: Node, symbol: Symbol): boolean {\n    if (Node.isPropertyAccessExpression(node)) {\n        const expression = node.getExpression();\n        if (Node.isThisExpression(expression)) {\n            const leftSymbol = node.getNameNode().getSymbol();\n            return leftSymbol === symbol;\n        }\n    } else if (Node.isIdentifier(node)) {\n        const leftSymbol = node.getSymbol();\n        return leftSymbol === symbol;\n    }\n    return false;\n}\n\nexport function getIsUnityAPIDeclaration(declaration: Node): boolean {\n    const sourceFile = declaration.getSourceFile();\n    return getIsUnityAPISourceFile(sourceFile);\n}\n\nfunction getGeniesScriptTypeFromNode(declaration: Node, isUnityType: boolean): GeniesScriptType {\n    if (declaration.getKind() !== SyntaxKind.ClassDeclaration || isUnityType) {\n        return GeniesScriptType.None;\n    }\n\n    const cls = declaration as ClassDeclaration;\n    const isMonobehaviour = extendsMonoBehaviour(cls);\n    const isScriptableObject = extendsScriptableObject(cls);\n\n    if (isMonobehaviour) {\n        return GeniesScriptType.Monobehaviour;\n    }\n\n    if (isScriptableObject) {\n        return GeniesScriptType.ScriptableObject;\n    }\n\n    return GeniesScriptType.None;\n}\n\nexport function getGeniesScriptTypeFromType(type: Type): GeniesScriptType {\n    const symbol = type.getSymbol();\n\n    if (!symbol) {\n        return GeniesScriptType.None;\n    }\n\n    const declarations = symbol.getDeclarations();\n    if (declarations.length === 0) {\n        return GeniesScriptType.None;\n    }\n\n    const declaration = declarations[0];\n    const isUnityType = getIsUnityAPIDeclaration(declaration)\n    return getGeniesScriptTypeFromNode(declaration, isUnityType);\n}\n\nexport function isGeniesScriptType(type: Type): boolean {\n    let gType = getGeniesScriptTypeFromType(type);\n    return gType === GeniesScriptType.Monobehaviour || gType === GeniesScriptType.ScriptableObject;\n}\n\n/**\n * Converts an absolute path to an alias path based on predefined rules.\n *\n * @param absolutePath - The absolute path to convert.\n * @returns The aliased path or null if it doesn't match any alias rules.\n */\nexport function convertToGeniesAliasPath(absolutePath: string): string | null {\n    // Normalize the path to use forward slashes\n    const normalizedPath = normalizePath(absolutePath);\n\n    // Check if the path includes '/Assets/'\n    const assetsPrefix = '/Assets/';\n    const assetsIndex = normalizedPath.indexOf(assetsPrefix);\n    if (assetsIndex !== -1) {\n        const relativePath = normalizedPath.substring(assetsIndex + assetsPrefix.length);\n        return `@assets/${relativePath}`;\n    }\n\n    // Check if the path includes '/com.genies.<package>/'\n    const comGeniesRegex = /\\/(com\\.genies\\.[^\\/]+)\\//;\n    const comGeniesMatch = normalizedPath.match(comGeniesRegex);\n    if (comGeniesMatch) {\n        const packageName = comGeniesMatch[1]; // e.g., com.genies.experience.sdk\n        const pathAfterPackage = normalizedPath.substring(comGeniesMatch.index! + comGeniesMatch[0].length);\n        return `@${packageName}/${pathAfterPackage}`;\n    }\n\n    // If no alias rule matches, return null\n    return null;\n}\n\n/**\n * Normalizes a file path to use forward slashes.\n *\n * @param p - The path to normalize.\n * @returns The normalized path.\n */\nfunction normalizePath(p: string): string {\n    return p.split(path.sep).join('/');\n}\n\n/**\n * Converts a relative import path to an alias path if applicable.\n *\n * @param root\n * @param relativePath - The relative import path.\n * @returns The aliased path or the original relative path if no alias applies.\n */\nexport function convertToAliasPath(root: string, relativePath: string): string {\n\n    const absolutePath = path.resolve(root, relativePath);\n    const aliasPath = convertToGeniesAliasPath(absolutePath);\n\n    if (aliasPath) {\n        return aliasPath;\n    }\n\n    // If no alias applies, return the normalized relative path\n    return relativePath;\n}\n\n/**\n * Updates import declarations in a source file to use alias paths for Assets/ and com.genies.* packages.\n *\n * @param sourceFile - The TypeScript source file to process.\n */\nexport function updateImportsToAliasPaths(sourceFile: SourceFile) {\n    const filePath = sourceFile.getDirectoryPath() as string;\n\n    sourceFile.getImportDeclarations().forEach(importDeclaration => {\n        const moduleSpecifier = importDeclaration.getModuleSpecifierValue();\n\n        // Check if the import path is relative\n        if (moduleSpecifier.startsWith('./') || moduleSpecifier.startsWith('../')) {\n            // Convert the relative path to an alias path\n            const aliasPath = convertToAliasPath(filePath, moduleSpecifier);\n\n            // Update the module specifier if it's been converted to an alias\n            if (aliasPath.startsWith('@assets/') || aliasPath.startsWith('@com.genies')) {\n                importDeclaration.setModuleSpecifier(aliasPath);\n            }\n        }\n    });\n}\n\nfunction extractDecorators(prop: PropertyDeclaration): GeniesDecoratorInfo[] {\n    return prop.getDecorators().map(d => {\n        const decoratorInfo: GeniesDecoratorInfo = {\n            Type: d.getName(),\n            Args: d.getArguments().map(a => a.getText())\n        };\n        return decoratorInfo;\n    });\n}\n","import {\n    CallExpression, MethodDeclaration,\n    Node,\n    PropertyDeclaration,\n    Symbol,\n    SyntaxKind, ts,\n    Type,\n    TypeChecker, TypeNode, TypeParameterDeclaration,\n    VariableDeclaration\n} from \"ts-morph\";\nimport {cleanTypeText, getTypeByName, isAssignmentToSymbol, NumericalAliases, typesAreEqual} from \"./CompilerUtils\";\nimport CallLikeExpression = ts.CallLikeExpression;\n\ninterface NumericLiteralInfo {\n    value: number;\n    hasDecimal: boolean;\n}\n\nexport function inferPossibleTypes(arg: Node, typeChecker: TypeChecker): Type[] {\n    const types: Type[] = [];\n    const argType = typeChecker.getTypeAtLocation(arg);\n\n    let inferredTypeNames: string[] = [];\n\n    const brandedType = getBrandedTypes(argType, typeChecker);\n    if (brandedType != null) {\n        types.push(brandedType);\n    } else {\n        // Attempt to get the numeric literal info\n        const numericInfo = getNumericValue(arg);\n        if (numericInfo !== undefined) {\n            inferredTypeNames = inferTypesFromNumericInfo(numericInfo);\n        } else {\n            // Use the argument's type\n            if (isNumberType(argType)) {\n                // Include all number types\n                inferredTypeNames = ['byte', 'sbyte', 'short', 'ushort', 'int', 'uint', 'float', 'double'];\n            } else {\n                types.push(argType);\n                return types;\n            }\n        }\n    }\n\n\n    // Convert type names to Type objects\n    for (const typeName of inferredTypeNames) {\n        const type = getTypeByName(typeName, typeChecker);\n        if (type) {\n            types.push(type);\n        }\n    }\n\n    return types;\n}\nexport function selectBestOverload(\n    overloads: MethodDeclaration[],\n    callExpression: CallExpression,\n    typeChecker: TypeChecker\n): MethodDeclaration | undefined {\n\n    if(!overloads || overloads.length <= 0) {\n        return undefined;\n    }\n\n    // If only 1 overload, return it.\n    if(overloads.length == 1) {\n        return overloads[0];\n    }\n\n    // Extract type arguments if present\n    const typeArguments = callExpression.getTypeArguments();\n    const hasExplicitTypeArgs = typeArguments && typeArguments.length > 0;\n\n    // First, filter overloads based on type arguments compatibility if explicit type args provided\n    const compatibleOverloads = hasExplicitTypeArgs\n        ? filterOverloadsByTypeArguments(overloads, typeArguments, typeChecker)\n        : overloads;\n\n    if (compatibleOverloads.length === 0) {\n        return undefined;\n    }\n\n    if (compatibleOverloads.length === 1) {\n        return compatibleOverloads[0];\n    }\n\n    const callArgs = callExpression.getArguments();\n\n    if(!callArgs || callArgs.length <= 0) {\n        const noArgOverload = compatibleOverloads.find(overload => {\n            const params = overload.getParameters();\n            return params.length === 0 || params.every(p => p.isOptional());\n        });\n        if (noArgOverload) {\n            return noArgOverload;\n        }\n\n        return undefined;\n    }\n\n    // Infer possible types for each argument\n    const argumentTypesList = callExpression.getArguments().map(arg =>\n        inferPossibleTypes(arg, typeChecker)\n    );\n\n    let bestOverload: MethodDeclaration | undefined;\n    let highestScore = -1;\n\n    for (const overload of compatibleOverloads) {\n        const score = scoreOverload(overload, argumentTypesList, typeChecker);\n        if (score > highestScore) {\n            highestScore = score;\n            bestOverload = overload;\n        }\n    }\n\n    return bestOverload;\n}\n\n// Function to filter overloads based on type arguments\nfunction filterOverloadsByTypeArguments(\n    overloads: MethodDeclaration[],\n    typeArgs: TypeNode[],\n    typeChecker: TypeChecker\n): MethodDeclaration[] {\n    return overloads.filter(overload => {\n        const typeParams = overload.getTypeParameters();\n\n        // If method has no type parameters but type args were provided, it's not compatible\n        if (!typeParams || typeParams.length === 0) {\n            return false;\n        }\n\n        // If number of type args doesn't match type parameters, it's not compatible\n        if (typeArgs.length !== typeParams.length) {\n            return false;\n        }\n\n        // Check each type argument against type parameter constraints\n        for (let i = 0; i < typeArgs.length; i++) {\n            const typeArg = typeChecker.getTypeAtLocation(typeArgs[i]);\n            const constraint = typeParams[i].getConstraint();\n\n            if (constraint) {\n                const constraintType = typeChecker.getTypeAtLocation(constraint);\n                if (!typeChecker.isTypeAssignableTo(typeArg, constraintType)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    });\n}\n\n// Keep the original scoring functions unchanged\nfunction scoreOverload(\n    overload: MethodDeclaration,\n    argumentTypesList: Type[][],\n    typeChecker: TypeChecker): number {\n    const parameters = overload.getParameters();\n\n    //Assume that its not the correct overload, this also accounts for the chance that params are optional.\n    if (parameters.length < argumentTypesList.length) return -1;\n\n    //If exact match of params to args we start the score at 1\n    let score = parameters.length == argumentTypesList.length ? 1 : 0;\n    for (let i = 0; i < parameters.length; i++) {\n        const paramType = typeChecker.getTypeAtLocation(parameters[i]);\n        const argTypes = argumentTypesList[i];\n\n        if(!argTypes || argTypes.length <= 0) {\n            return -1;\n        }\n\n        const argScore = scoreParameter(paramType, argTypes, typeChecker);\n        if (argScore < 0) {\n            return -1;\n        }\n        score += argScore;\n    }\n\n    return score;\n}\n\nfunction scoreParameter(\n    paramType: Type,\n    possibleArgTypes: Type[],\n    typeChecker: TypeChecker\n): number {\n    let bestScore = -1;\n\n    // 1) If it's a type parameter, see if we can unify with the constraint\n    if (paramType.isTypeParameter()) {\n        const constraint = paramType.getConstraint();\n        if (!constraint) {\n            if (possibleArgTypes.length > 0) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n\n        for (const argType of possibleArgTypes) {\n            if (typesAreEqual(argType, constraint)) {\n                bestScore = Math.max(bestScore, 2);\n            } else if (typeChecker.isTypeAssignableTo(argType, constraint)) {\n                bestScore = Math.max(bestScore, 1);\n            }\n        }\n        return bestScore;\n    }\n\n    // 2) If paramType is a recognized numeric type\n    if (isValidNumericalType(paramType)) {\n        // numeric param => exact match => score 2, otherwise castable => 1\n        for (const argType of possibleArgTypes) {\n            if (typesAreEqual(argType, paramType)) {\n                bestScore = Math.max(bestScore, 2);\n            } else if (isNumericCastable(argType, paramType)) {\n                bestScore = Math.max(bestScore, 1);\n            }\n        }\n        return bestScore;\n    }\n\n    // 3) Non-numeric, non-type-parameter exact match or isTypeAssignableTo.\n    for (const argType of possibleArgTypes) {\n        if (typesAreEqual(argType, paramType)) {\n            bestScore = Math.max(bestScore, 2);\n        } else if (typeChecker.isTypeAssignableTo(argType, paramType)) {\n            bestScore = Math.max(bestScore, 1);\n        }\n    }\n\n    return bestScore;\n}\n\nfunction isValidNumericalType(type: Type): boolean {\n    const typeText = cleanTypeText(type.getText());\n\n    return NumericalAliases.has(typeText);\n}\n\nexport function isNumericCastable(fromType: Type, toType: Type): boolean {\n    const castabilityMap: { [key: string]: string[] } = {\n        byte: ['short', 'ushort', 'int', 'uint', 'float', 'double', 'number'],\n        sbyte: ['short', 'int', 'float', 'double', 'number'],\n        short: ['int', 'float', 'double', 'number'],\n        ushort: ['int', 'uint', 'float', 'double', 'number'],\n        int: ['float', 'double', 'number'],\n        uint: ['float', 'double', 'number'],\n        float: ['double', 'number'],\n        double: ['number'],\n        number: ['byte', 'sbyte', 'short', 'ushort', 'int', 'uint', 'float', 'double'],\n    };\n\n    const fromTypeName = cleanTypeText(fromType.getText());\n    const toTypeName = cleanTypeText(toType.getText());\n\n    return castabilityMap[fromTypeName]?.includes(toTypeName) ?? false;\n}\n\nexport function getNumericValue(arg: Node): NumericLiteralInfo | undefined {\n    // Handle numeric literals and negative numbers\n    const numericLiteralInfo = getNumericLiteralInfo(arg);\n    if (numericLiteralInfo !== undefined) {\n        return numericLiteralInfo;\n    }\n\n    // Handle variables and properties by performing flow analysis\n    if (Node.isIdentifier(arg) || Node.isPropertyAccessExpression(arg)) {\n        const symbol = arg.getSymbol();\n        if (symbol) {\n            const declarations = symbol.getDeclarations();\n            if (declarations && declarations.length > 0) {\n                const decl = declarations[0];\n                if (Node.isVariableDeclaration(decl) || Node.isPropertyDeclaration(decl)) {\n                    // Perform flow analysis to get the variable's value at the point of usage\n                    const valueInfo = performFlowAnalysis(symbol, decl, arg);\n                    if (valueInfo) {\n                        return valueInfo;\n                    }\n                }\n            }\n        }\n    }\n\n    return undefined;\n}\n\nfunction isNumberType(type: Type): boolean {\n    const typeText = cleanTypeText(type.getText());\n    return typeText === 'number';\n}\n\nfunction getNumericLiteralInfo(arg: Node): NumericLiteralInfo | undefined {\n    if (Node.isNumericLiteral(arg)) {\n        const text = arg.getText();\n        const value = Number(text);\n        const hasDecimal = text.includes('.');\n        return {value, hasDecimal};\n    } else if (Node.isPrefixUnaryExpression(arg) && arg.getOperatorToken() === SyntaxKind.MinusToken) {\n        const operand = arg.getOperand();\n        if (Node.isNumericLiteral(operand)) {\n            const text = operand.getText();\n            const value = -Number(text);\n            const hasDecimal = text.includes('.');\n            return {value, hasDecimal};\n        }\n    }\n    return undefined;\n}\n\nfunction inferTypesFromNumericInfo(info: NumericLiteralInfo): string[] {\n    const {value, hasDecimal} = info;\n    const types = new Set<string>();\n\n    if (!hasDecimal) {\n        // Original literal did not have a decimal point; treat as integer\n        if (value >= -2147483648 && value <= 2147483647) {\n            types.add('int');\n        }\n        if (value >= -32768 && value <= 32767) {\n            types.add('short');\n        }\n        if (value >= -128 && value <= 127) {\n            types.add('sbyte');\n        }\n        if (value >= 0 && value <= 255) {\n            types.add('byte');\n        }\n        if (value >= 0 && value <= 65535) {\n            types.add('ushort');\n        }\n        if (value >= 0 && value <= 4294967295) {\n            types.add('uint');\n        }\n    } else {\n        // Original literal had a decimal point; treat as float\n        types.add('float');\n        types.add('double');\n    }\n\n    return Array.from(types);\n}\n\nfunction getBrandedTypes(type: Type, typeChecker: TypeChecker): Type | null {\n\n    const typeText = type.getText();\n\n    if (NumericalAliases.has(typeText)) {\n        const brandedType = getTypeByName(typeText, typeChecker);\n        if (brandedType) {\n            return brandedType;\n        }\n    }\n\n    // Check for branded types by looking for '& { __brand?: undefined }'\n    const match = typeText.match(/number\\s*&\\s*\\{\\s*__([a-zA-Z]+)Brand\\?:\\s*undefined\\s*\\}/);\n    if (match) {\n        const brand = match[1];\n        const typeName = brand;\n\n        const brandedType = getTypeByName(typeName, typeChecker);\n        if (brandedType) {\n            return brandedType;\n        }\n    }\n\n    return null;\n}\n\n\nfunction performFlowAnalysis(\n    symbol: Symbol,\n    declaration: VariableDeclaration | PropertyDeclaration,\n    usageNode: Node\n): NumericLiteralInfo | undefined {\n    let currentValueInfo: NumericLiteralInfo | undefined = undefined;\n\n    // First, check if the variable/property has an initializer\n    const initializer = declaration.getInitializer();\n    if (initializer) {\n        const initValueInfo = getNumericValueFromExpression(initializer, symbol, declaration, usageNode);\n        if (initValueInfo) {\n            currentValueInfo = initValueInfo;\n        }\n    }\n\n    // Find the method where the usage occurs\n    const methodDeclaration = usageNode.getFirstAncestorByKind(SyntaxKind.MethodDeclaration);\n    if (!methodDeclaration) {\n        return currentValueInfo; // Cannot proceed without method context\n    }\n\n    const statements = methodDeclaration.getStatements() || [];\n\n    let tracking = true; // Since we only care about the method scope, we can start tracking immediately\n\n    const usageStart = usageNode.getStart();\n\n    for (const stmt of statements) {\n        if (stmt.getStart() > usageStart) {\n            // Reached the usage point\n            break;\n        }\n\n        if (tracking) {\n            // Check for assignments to the variable/property\n            const assignments = stmt.getDescendants().filter(node =>\n                Node.isBinaryExpression(node) ||\n                Node.isPrefixUnaryExpression(node) ||\n                Node.isPostfixUnaryExpression(node)\n            );\n\n            for (const assignment of assignments) {\n                if (Node.isBinaryExpression(assignment)) {\n                    const operatorKind = assignment.getOperatorToken().getKind();\n                    const left = assignment.getLeft();\n                    const right = assignment.getRight();\n\n                    if (isAssignmentToSymbol(left, symbol)) {\n                        if (operatorKind === SyntaxKind.EqualsToken) {\n                            // Simple assignment\n                            const valueInfo = getNumericValueFromExpression(\n                                right,\n                                symbol,\n                                declaration,\n                                usageNode,\n                                currentValueInfo\n                            );\n                            if (valueInfo) {\n                                currentValueInfo = valueInfo;\n                            } else {\n                                currentValueInfo = undefined;\n                            }\n                        } else if (\n                            [\n                                SyntaxKind.PlusEqualsToken,\n                                SyntaxKind.MinusEqualsToken,\n                                SyntaxKind.AsteriskEqualsToken,\n                                SyntaxKind.SlashEqualsToken,\n                                SyntaxKind.PercentEqualsToken,\n                            ].includes(operatorKind)\n                        ) {\n                            // Compound assignment\n                            const valueInfo = getNumericValueFromExpression(\n                                right,\n                                symbol,\n                                declaration,\n                                usageNode,\n                                currentValueInfo\n                            );\n                            if (valueInfo && currentValueInfo) {\n                                const resultValueInfo = evaluateCompoundAssignment(\n                                    operatorKind,\n                                    currentValueInfo,\n                                    valueInfo\n                                );\n                                if (resultValueInfo) {\n                                    currentValueInfo = resultValueInfo;\n                                } else {\n                                    currentValueInfo = undefined;\n                                }\n                            } else {\n                                currentValueInfo = undefined;\n                            }\n                        }\n                    }\n                } else if (Node.isPrefixUnaryExpression(assignment) || Node.isPostfixUnaryExpression(assignment)) {\n                    const operatorKind = assignment.getOperatorToken();\n                    const operand = assignment.getOperand();\n\n                    if (isAssignmentToSymbol(operand, symbol)) {\n                        // Increment or decrement\n                        if (currentValueInfo) {\n                            let delta = operatorKind === SyntaxKind.PlusPlusToken ? 1 : -1;\n                            currentValueInfo = {\n                                value: currentValueInfo.value + delta,\n                                hasDecimal: currentValueInfo.hasDecimal,\n                            };\n                        } else {\n                            currentValueInfo = undefined;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return currentValueInfo;\n}\n\n\nfunction getNumericValueFromExpression(\n    expr: Node,\n    symbol: Symbol,\n    declaration: VariableDeclaration | PropertyDeclaration,\n    usageNode: Node,\n    currentValueInfo?: NumericLiteralInfo\n): NumericLiteralInfo | undefined {\n    if (Node.isNumericLiteral(expr)) {\n        return getNumericLiteralInfo(expr);\n    } else if (Node.isIdentifier(expr) || Node.isPropertyAccessExpression(expr)) {\n        if (isAssignmentToSymbol(expr, symbol)) {\n            // Use the current value of the variable/property\n            return currentValueInfo;\n        } else {\n            // Retrieve the value of another variable or property\n            const exprSymbol = expr.getSymbol();\n            if (exprSymbol) {\n                const declarations = exprSymbol.getDeclarations();\n                if (declarations && declarations.length > 0) {\n                    const decl = declarations[0];\n                    if (Node.isVariableDeclaration(decl) || Node.isPropertyDeclaration(decl)) {\n                        return performFlowAnalysis(exprSymbol, decl, expr);\n                    }\n                }\n            }\n        }\n    } else if (Node.isBinaryExpression(expr)) {\n        const leftInfo = getNumericValueFromExpression(\n            expr.getLeft(),\n            symbol,\n            declaration,\n            usageNode,\n            currentValueInfo\n        );\n        const rightInfo = getNumericValueFromExpression(\n            expr.getRight(),\n            symbol,\n            declaration,\n            usageNode,\n            currentValueInfo\n        );\n\n        if (leftInfo && rightInfo) {\n            const operatorKind = expr.getOperatorToken().getKind();\n            return evaluateBinaryOperation(operatorKind, leftInfo, rightInfo);\n        }\n    }\n\n    return undefined;\n}\n\nfunction evaluateCompoundAssignment(\n    operatorKind: SyntaxKind,\n    leftInfo: NumericLiteralInfo,\n    rightInfo: NumericLiteralInfo\n): NumericLiteralInfo | undefined {\n    const operatorMap: { [key: number]: SyntaxKind } = {\n        [SyntaxKind.PlusEqualsToken]: SyntaxKind.PlusToken,\n        [SyntaxKind.MinusEqualsToken]: SyntaxKind.MinusToken,\n        [SyntaxKind.AsteriskEqualsToken]: SyntaxKind.AsteriskToken,\n        [SyntaxKind.SlashEqualsToken]: SyntaxKind.SlashToken,\n        [SyntaxKind.PercentEqualsToken]: SyntaxKind.PercentToken,\n    };\n    const binaryOperatorKind = operatorMap[operatorKind];\n    if (binaryOperatorKind !== undefined) {\n        return evaluateBinaryOperation(binaryOperatorKind, leftInfo, rightInfo);\n    }\n    return undefined;\n}\n\nfunction evaluateBinaryOperation(\n    operatorKind: SyntaxKind,\n    leftInfo: NumericLiteralInfo,\n    rightInfo: NumericLiteralInfo\n): NumericLiteralInfo | undefined {\n    let resultValue: number | undefined;\n    let hasDecimal = leftInfo.hasDecimal || rightInfo.hasDecimal;\n\n    switch (operatorKind) {\n        case SyntaxKind.PlusToken:\n            resultValue = leftInfo.value + rightInfo.value;\n            break;\n        case SyntaxKind.MinusToken:\n            resultValue = leftInfo.value - rightInfo.value;\n            break;\n        case SyntaxKind.AsteriskToken:\n            resultValue = leftInfo.value * rightInfo.value;\n            break;\n        case SyntaxKind.SlashToken:\n            resultValue = leftInfo.value / rightInfo.value;\n            hasDecimal = true; // Division can result in a decimal\n            break;\n        case SyntaxKind.PercentToken:\n            resultValue = leftInfo.value % rightInfo.value;\n            break;\n        default:\n            return undefined;\n    }\n\n    if (resultValue !== undefined) {\n        return {value: resultValue, hasDecimal};\n    }\n\n    return undefined;\n}\n\n","import {\n    SourceFile,\n    Node,\n    SyntaxKind,\n    CallExpression,\n    MethodDeclaration,\n    Type,\n    ClassDeclaration,\n    TypeChecker\n} from \"ts-morph\";\nimport ts from \"typescript/lib/tsserverlibrary\";\nimport {\n    getIsUnityAPIType,\n    getIsUnityAPIDeclaration,\n    getGeniesScriptTypeFromType,\n    GeniesScriptType,\n    getFullTypeName,\n    AllowedUiInterfaces,\n    getIsValidUnityGenericTypeArg,\n    GET_ITEM_NAME,\n    SET_ITEM_NAME,\n    inheritsFrom, getBaseTypes, isTypeAssignableTo, isUserDefinedType\n} from \"./CompilerUtils\";\nimport {selectBestOverload} from \"./MethodOverloadUtils\";\n\nconst CUSTOM_DIAGNOSTIC_CODES = {\n    INVALID_INHERITANCE: 10001,\n    FORBIDDEN_INTERFACE: 10002,\n    GENERIC_METHOD_MISSING_TYPE_ARGUMENTS: 10003,\n    GENERIC_METHOD_INVALID_TYPE_ARGUMENTS: 10004,\n    GENERIC_CLASS_MISSING_TYPE_ARGUMENTS: 10005,\n    GENERIC_CLASS_INVALID_TYPE_ARGUMENTS: 10006,\n    INVALID_GET_ITEM_ARGUMENTS: 10007,\n    INCOMPATIBLE_PARAMETER_TYPE: 10008\n};\n\nconst ALLOWED_INHERITANCE_TYPES = new Set(['MonoBehaviour', 'ScriptableObject']);\n\nconst COMPONENT_METHODS = new Set([\n    'GetComponent',\n    'TryGetComponent',\n    'GetComponentInChildren',\n    'GetComponentsInChildren',\n    'GetComponentInParent',\n    'GetComponentsInParent',\n    'GetComponents',\n    'AddComponent',\n]);\n\n\nexport function getGeniesSemanticDiagnostics(file: SourceFile, typeChecker: TypeChecker): ts.Diagnostic[] {\n    if (!file) {\n        return [];\n    }\n\n    const diagnostics: ts.Diagnostic[] = [];\n\n    processClassDiagnostics(file, diagnostics);\n    processCallExpressionDiagnostics(file, diagnostics, typeChecker);\n    processTypeUsageDiagnostics(file, diagnostics);\n    \n    //TODO improve diagnostics for bracket access\n    //processBracketAccessDiagnostics(file, typeChecker, diagnostics);\n\n    return diagnostics;\n}\n\n//TODO improve diagnostics for bracket access\n// function processBracketAccessDiagnostics(file: SourceFile, typeChecker: TypeChecker, diagnostics: ts.Diagnostic[]) {\n//\n//     let expressions = file.getDescendantsOfKind(SyntaxKind.ElementAccessExpression);\n//\n//     if (expressions.length === 0) {\n//         return;\n//     }\n//\n//     expressions.forEach(node => {\n//         const elementAccess = node as ElementAccessExpression;\n//         const expression = elementAccess.getExpression();\n//         const argumentExpression = elementAccess.getArgumentExpression();\n//\n//         if (!argumentExpression) {\n//             // If there's no argument (e.g., obj[]), skip transformation\n//             return node;\n//         }\n//\n//         const type = expression.getType();\n//\n//         // Check if the type is a Unity API type\n//         if (!getIsUnityAPIType(type)) {\n//             return node;\n//         }\n//\n//         // Retrieve the symbol of the type\n//         const typeSymbol = type.getSymbol();\n//         if (!typeSymbol) {\n//             return;\n//         }\n//\n//         // Get all declarations (classes and interfaces) associated with the type\n//         const declarations = typeSymbol.getDeclarations().filter(\n//             decl => Node.isClassDeclaration(decl) || Node.isInterfaceDeclaration(decl)\n//         ) as (ClassDeclaration | InterfaceDeclaration)[];\n//\n//         if (declarations.length === 0) {\n//             return;\n//         }\n//\n//         // Collect all unique get_item and set_item methods across all declarations\n//         const getItemMethods: (MethodDeclaration | MethodSignature)[] = [];\n//         const setItemMethods: (MethodDeclaration | MethodSignature)[] = [];\n//\n//         const methodSignatures = new Set<string>();\n//\n//         declarations.forEach(decl => {\n//             const classOrInterface = decl as ClassDeclaration | InterfaceDeclaration;\n//\n//             // getMethods returns an array of MethodDeclaration or MethodSignature\n//             const methods = classOrInterface.getMethods();\n//\n//             methods.forEach(method => {\n//                 const methodName = method.getName();\n//                 if (methodName === GET_ITEM_NAME || methodName === SET_ITEM_NAME) {\n//                     // Generate a unique signature string for the method\n//                     const signature = method.getSignature().getDeclaration()?.getText();\n//                     if (signature && !methodSignatures.has(signature)) {\n//                         if (methodName === GET_ITEM_NAME) {\n//                             getItemMethods.push(method);\n//                         } else {\n//                             setItemMethods.push(method);\n//                         }\n//                         methodSignatures.add(signature);\n//                     }\n//                 }\n//             });\n//         });\n//\n//         if (getItemMethods.length === 0 && setItemMethods.length === 0) {\n//             return;\n//         }\n//\n//         const parent = elementAccess.getParent();\n//\n//         // Determine if this is a getter or setter\n//         if (\n//             Node.isBinaryExpression(parent) &&\n//             parent.getOperatorToken().getKind() === SyntaxKind.EqualsToken &&\n//             parent.getLeft() === elementAccess\n//         ) {\n//             // This is a setter: obj[index] = value\n//             if (setItemMethods.length === 0) {\n//                 return;\n//             }\n//\n//             const valueExpression = parent.getRight();\n//\n//             // Attempt to find a matching set_item method\n//             const matchingSetItem = setItemMethods.find(method => {\n//                 const params = method.getParameters();\n//                 if (params.length !== 2) {\n//                     return false;\n//                 }\n//\n//                 const indexParamType = params[0].getType();\n//                 const valueParamType = params[1].getType();\n//\n//                 const indexArgType = argumentExpression.getType();\n//                 const valueArgType = valueExpression.getType();\n//\n//                 return (\n//                     typeChecker.isTypeAssignableTo(indexArgType, indexParamType) &&\n//                     typeChecker.isTypeAssignableTo(valueArgType, valueParamType)\n//                 );\n//             });\n//\n//             if (!matchingSetItem) {\n//                 addDiagnostic(\n//                     diagnostics,\n//                     node,\n//                     `Invalid Assignment`,\n//                     CUSTOM_DIAGNOSTIC_CODES.INVALID_GET_ITEM_ARGUMENTS);\n//             }\n//         } else {\n//             // This is a getter: obj[index]\n//             if (getItemMethods.length === 0) {\n//                 return node;\n//             }\n//\n//             // Attempt to find a matching get_item method\n//             const matchingGetItem = getItemMethods.find(method => {\n//                 const params = method.getParameters();\n//                 if (params.length !== 1) {\n//                     return false;\n//                 }\n//\n//                 const indexParamType = params[0].getType();\n//                 const indexArgType = argumentExpression.getType();\n//\n//                 return typeChecker.isTypeAssignableTo(indexArgType, indexParamType);\n//             });\n//\n//             let validParams = getItemMethods.flatMap(g => g.getParameters().map(p => getFullTypeName(p.getType())));\n//\n//             if (!matchingGetItem) {\n//                 addDiagnostic(\n//                     diagnostics,\n//                     node,\n//                     `Invalid access, accepted types are '${validParams.join(\",\")}'`,\n//                     CUSTOM_DIAGNOSTIC_CODES.INVALID_GET_ITEM_ARGUMENTS);\n//             }\n//         }\n//     });\n// }\n\nfunction processClassDiagnostics(file: SourceFile, diagnostics: ts.Diagnostic[]) {\n    const geniesClasses = file.getClasses();\n\n    geniesClasses.forEach(cls => {\n        const baseClass = cls.getBaseClass();\n        const implementedInterfaces = cls.getImplements();\n        const baseClassName = baseClass?.getName();\n\n        if (baseClass && getIsUnityAPIType(baseClass.getType()) && baseClassName && !ALLOWED_INHERITANCE_TYPES.has(baseClassName)) {\n            const start = baseClass.getStart();\n            const length = baseClass.getName()?.length;\n\n            const diagnosticMessage = `Class '${cls.getName()}' inherits from a Unity type '${baseClass.getName()}' that is not 'MonoBehaviour' or 'ScriptableObject'.`;\n            const diagnostic: ts.Diagnostic = {\n                file: file.compilerNode,\n                start: start,\n                length: length,\n                messageText: diagnosticMessage,\n                category: ts.DiagnosticCategory.Error,\n                code: CUSTOM_DIAGNOSTIC_CODES.INVALID_INHERITANCE,\n                source: 'Genies',\n            };\n            diagnostics.push(diagnostic);\n        }\n\n        implementedInterfaces.forEach(intf => {\n            if (getIsUnityAPIType(intf.getType())) {\n\n                const typeName = getFullTypeName(intf.getType());\n                if (AllowedUiInterfaces.has(typeName)) {\n                    return;\n                }\n\n                const start = intf.getStart();\n                const length = intf.getWidth();\n\n                const diagnosticMessage = `Class '${cls.getName()}' implements a forbidden Unity interface '${intf.getText()}'.`;\n                const diagnostic: ts.Diagnostic = {\n                    file: file.compilerNode,\n                    start: start,\n                    length: length,\n                    messageText: diagnosticMessage,\n                    category: ts.DiagnosticCategory.Error,\n                    code: CUSTOM_DIAGNOSTIC_CODES.FORBIDDEN_INTERFACE,\n                    source: 'Genies',\n                };\n                diagnostics.push(diagnostic);\n            }\n        });\n    });\n}\n\nfunction processTypeUsageDiagnostics(file: SourceFile, diagnostics: ts.Diagnostic[]) {\n    // Gather all NewExpression and TypeReferenceNode instances\n    const newExpressions = file.getDescendantsOfKind(SyntaxKind.NewExpression);\n\n    // Process NewExpression nodes\n    newExpressions.forEach(newExpr => {\n        // Resolve the symbol of the class being instantiated\n        const typeSymbol = newExpr.getType().getSymbol();\n\n        if (!typeSymbol) {\n            return;\n        }\n\n        // Retrieve all declarations of the symbol\n        const declarations = typeSymbol.getDeclarations();\n\n        if (!declarations || declarations.length === 0) {\n            return;\n        }\n\n        // Filter for class declarations with type parameters (i.e., generic classes)\n        const classDeclarations = declarations.filter(decl =>\n            Node.isClassDeclaration(decl) && getIsUnityAPIDeclaration(decl) && decl.getTypeParameters().length > 0\n        ) as ClassDeclaration[];\n\n        if (classDeclarations.length === 0) {\n            return; // Not a generic class\n        }\n\n        const classDeclaration = classDeclarations[0];\n        const typeParams = classDeclaration.getTypeParameters();\n        const expectedTypeArgsCount = typeParams.length;\n\n        // Retrieve provided type arguments from the NewExpression\n        const typeArgs = newExpr.getTypeArguments();\n        const providedTypeArgsCount = typeArgs.length;\n\n        if (providedTypeArgsCount === 0) {\n            // Generic class used without type arguments\n            addDiagnostic(\n                diagnostics,\n                newExpr,\n                `Generic class '${getFullTypeName(newExpr.getType())}' must be instantiated with ${expectedTypeArgsCount} type argument(s).`,\n                CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_MISSING_TYPE_ARGUMENTS\n            );\n        } else {\n            if (providedTypeArgsCount !== expectedTypeArgsCount) {\n                // Incorrect number of type arguments provided\n                addDiagnostic(\n                    diagnostics,\n                    newExpr,\n                    `Generic class '${getFullTypeName(newExpr.getType())}' expects ${expectedTypeArgsCount} type argument(s), but got ${providedTypeArgsCount}.`,\n                    CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_INVALID_TYPE_ARGUMENTS\n                );\n            }\n\n            //Invalid args\n            typeArgs.forEach(typeArgNode => {\n                const typeArgType = typeArgNode.getType();\n                if (!getIsValidUnityGenericTypeArg(typeArgType)) {\n                    \n                    addDiagnostic(\n                        diagnostics,\n                        typeArgNode,\n                        `Type arguments for type '${getFullTypeName(newExpr.getType())}' must be Unity API types.`,\n                        CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_INVALID_TYPE_ARGUMENTS\n                    );\n                }\n            });\n\n        }\n    });\n}\n\n\nfunction processCallExpressionDiagnostics(file: SourceFile, diagnostics: ts.Diagnostic[], typeChecker: TypeChecker) {\n    const callExpressions = file.getDescendantsOfKind(SyntaxKind.CallExpression);\n\n    callExpressions.forEach(callExpr => {\n        processGenericMethodCall(callExpr, diagnostics);\n        checkParameterTypesForUnityApiCalls(callExpr, diagnostics, typeChecker)\n    });\n}\nfunction checkParameterTypesForUnityApiCalls(callExpr: CallExpression, diagnostics: ts.Diagnostic[], typeChecker: TypeChecker) {\n    const expression = callExpr.getExpression();\n\n    // Determine if this is a Unity API method call\n    if (!Node.isPropertyAccessExpression(expression)) {\n        return;\n    }\n\n    const propertyAccess = expression.asKind(SyntaxKind.PropertyAccessExpression);\n    const symbol = propertyAccess?.getSymbol();\n    if (!symbol) {\n        return;\n    }\n\n    const declarations = symbol.getDeclarations();\n\n    if(!declarations || declarations.length <= 0) {\n        return;\n    }\n\n    const overloadDeclarations = declarations.filter(decl =>\n        Node.isMethodDeclaration(decl) || Node.isMethodSignature(decl)\n    ) as MethodDeclaration[];\n\n    if (overloadDeclarations.length === 0) {\n        return;\n    }\n\n    const methodDeclaration = overloadDeclarations[0] as MethodDeclaration;\n\n    if (!getIsUnityAPIDeclaration(methodDeclaration)) {\n        return;\n    }\n\n    // Perform overload resolution\n    const bestOverload = selectBestOverload(overloadDeclarations, callExpr, typeChecker);\n\n    if (!bestOverload) {\n        // No suitable overload found; fallback to the first overload\n        return;\n    }\n\n    // Get the parameters from the method signature\n    const parameters = bestOverload.getParameters();\n    const args = callExpr.getArguments();\n\n    // Get the type arguments if provided\n    const typeArguments = callExpr.getTypeArguments();\n    const methodTypeParams = bestOverload.getTypeParameters();\n    const hasTypeArgs = typeArguments && typeArguments.length > 0 && methodTypeParams && methodTypeParams.length > 0;\n\n    // Create a map of type parameter names to their resolved types\n    const typeParamMap = new Map<string, Type>();\n\n    if (hasTypeArgs) {\n        // If explicit type arguments were provided, use them\n        for (let i = 0; i < Math.min(typeArguments.length, methodTypeParams.length); i++) {\n            typeParamMap.set(methodTypeParams[i].getName(), typeChecker.getTypeAtLocation(typeArguments[i]));\n        }\n    }\n\n    // Check each argument against the corresponding parameter type\n    for (let i = 0; i < Math.min(parameters.length, args.length); i++) {\n        const parameter = parameters[i];\n        const argument = args[i];\n\n        let parameterType = parameter.getType();\n        const argumentType = argument.getType();\n        \n        if(!isUserDefinedType(argumentType))\n        {\n            continue;\n        }\n\n        // If the parameter type is a type parameter, resolve it\n        if (parameterType.isTypeParameter()) {\n            const typeParamName = parameterType.getSymbol()?.getName();\n            if (typeParamName && typeParamMap.has(typeParamName)) {\n                // Use the resolved type from the map\n                parameterType = typeParamMap.get(typeParamName)!;\n            } else if (parameterType.getConstraint()) {\n                // Fallback to the constraint if we couldn't resolve the type parameter\n                parameterType = parameterType.getConstraint()!;\n            }\n        }\n\n        // Use the inheritance checking utilities with the resolved parameter type\n        if (!isTypeCompatibleWithParameter(argumentType, parameterType, typeChecker)) {\n            addDiagnostic(\n                diagnostics,\n                argument,\n                `Argument of type '${getFullTypeName(argumentType)}' is not assignable to parameter of type '${getFullTypeName(parameterType)}'.`,\n                CUSTOM_DIAGNOSTIC_CODES.INCOMPATIBLE_PARAMETER_TYPE\n            );\n        }\n    }\n}\n\n// Helper function to check if a type is compatible with a parameter type\nfunction isTypeCompatibleWithParameter(\n    argumentType: Type,\n    parameterType: Type,\n    typeChecker: TypeChecker\n): boolean {\n    \n    return isTypeAssignableTo(argumentType, parameterType, typeChecker);\n}\n\nfunction processGenericMethodCall(callExpr: CallExpression, diagnostics: ts.Diagnostic[]) {\n    const expression = callExpr.getExpression();\n\n    // Get the method symbol and all declarations\n    let methodDeclarations: MethodDeclaration[] = [];\n\n    if (Node.isPropertyAccessExpression(expression) || Node.isIdentifier(expression)) {\n        const methodSymbol = expression.getSymbol();\n        if (methodSymbol) {\n            const declarations = methodSymbol.getDeclarations();\n            methodDeclarations = declarations.filter(decl => Node.isMethodDeclaration(decl)) as MethodDeclaration[];\n        }\n    }\n\n    if (methodDeclarations.length === 0) {\n        return; // Cannot proceed without method declarations\n    }\n\n    let isGenericMethodDeclaration = methodDeclarations.filter(decl => {\n        return decl.getTypeParameters().length > 0\n    }).length > 0;\n\n    if (!isGenericMethodDeclaration) {\n        return;\n    }\n\n    // Filter to Unity API methods\n    methodDeclarations = methodDeclarations.filter(decl => getIsUnityAPIDeclaration(decl));\n\n    if (methodDeclarations.length === 0) {\n        return; // No Unity API methods\n    }\n\n    const methodName = getMethodName(expression);\n\n    // Check for non-generic overloads that accept the same parameters\n    if (hasMatchingNonGenericOverload(methodDeclarations, callExpr)) {\n        return; // Skip the check since a non-generic overload exists\n    }\n\n    // Now, ensure that the call provides type arguments\n    const typeArgs = callExpr.getTypeArguments();\n\n    if (typeArgs.length === 0) {\n        // Generic method called without specifying type arguments\n        addDiagnostic(\n            diagnostics,\n            callExpr,\n            `Generic method '${methodName}' must be called with type arguments.`,\n            CUSTOM_DIAGNOSTIC_CODES.GENERIC_METHOD_MISSING_TYPE_ARGUMENTS\n        );\n        return;\n    }\n\n    let validArgs = methodDeclarations.map(m => m.getTypeParameters().length);\n    if (!validArgs.includes(typeArgs.length)) {\n        // Incorrect number of type arguments provided\n        addDiagnostic(\n            diagnostics,\n            callExpr,\n            `Generic method '${methodName}' was provided the wrong number of arguments. Valid args counts: '${validArgs.join(\", \")}'`,\n            CUSTOM_DIAGNOSTIC_CODES.GENERIC_CLASS_INVALID_TYPE_ARGUMENTS\n        );\n    }\n\n    // Validate type arguments\n    if (COMPONENT_METHODS.has(methodName)) {\n        // Apply GetComponent rules\n        typeArgs.forEach(typeArgNode => {\n            if (!isValidComponentTypeArg(typeArgNode)) {\n                addDiagnostic(\n                    diagnostics,\n                    typeArgNode,\n                    `Type arguments for method '${methodName}' must be a Unity API type, an interface, or a type that extends MonoBehaviour.`,\n                    CUSTOM_DIAGNOSTIC_CODES.GENERIC_METHOD_INVALID_TYPE_ARGUMENTS\n                );\n            }\n        });\n    } else {\n        // For other methods, type arguments must be Unity API types\n        typeArgs.forEach(typeArgNode => {\n            const typeArgType = typeArgNode.getType();\n            if (!getIsValidUnityGenericTypeArg(typeArgType)) {\n                addDiagnostic(\n                    diagnostics,\n                    typeArgNode,\n                    `Type arguments for method '${methodName}' must be Unity API types.`,\n                    CUSTOM_DIAGNOSTIC_CODES.GENERIC_METHOD_INVALID_TYPE_ARGUMENTS\n                );\n            }\n        });\n    }\n}\n\nfunction hasMatchingNonGenericOverload(\n    methodDeclarations: MethodDeclaration[],\n    callExpr: CallExpression\n): boolean {\n    const callArgTypes = callExpr.getArguments().map(arg => arg.getType());\n    const typeChecker = callExpr.getProject().getTypeChecker();\n\n    return methodDeclarations.some(decl => {\n        if (decl.getTypeParameters().length > 0) {\n            return false; // It's a generic method\n        }\n\n        const parameters = decl.getParameters();\n        if (parameters.length !== callArgTypes.length) {\n            return false;\n        }\n\n        // Compare parameter types\n        for (let i = 0; i < parameters.length; i++) {\n            const paramType = parameters[i].getType();\n            const argType = callArgTypes[i];\n\n            if (!typeChecker.isTypeAssignableTo(argType, paramType)) {\n                return false;\n            }\n        }\n\n        return true; // Found a matching non-generic overload\n    });\n}\n\nfunction isValidComponentTypeArg(typeArgNode: Node): boolean {\n    const typeArgType = typeArgNode.getType();\n\n    if (getIsValidUnityGenericTypeArg(typeArgType)) {\n        // It's a Unity API type, acceptable\n        return true;\n    }\n\n    const geniesScriptType = getGeniesScriptTypeFromType(typeArgType);\n    if (geniesScriptType === GeniesScriptType.Monobehaviour) {\n        // It's a MonoBehaviour, acceptable\n        return true;\n    }\n\n    const symbol = typeArgType.getSymbol();\n    if (symbol) {\n        const declarations = symbol.getDeclarations();\n        if (declarations && declarations.length > 0) {\n            if (Node.isInterfaceDeclaration(declarations[0])) {\n                // It's an interface, acceptable\n                return true;\n            }\n        }\n    }\n\n    return false; // Invalid type argument\n}\n\nfunction getMethodName(expression: Node): string {\n    if (Node.isPropertyAccessExpression(expression)) {\n        return expression.getName();\n    } else if (Node.isIdentifier(expression)) {\n        return expression.getText();\n    } else {\n        return ''; // Unknown\n    }\n}\n\nfunction addDiagnostic(\n    diagnostics: ts.Diagnostic[],\n    node: Node,\n    messageText: string,\n    code: number\n) {\n    const start = node.getStart();\n    const length = node.getWidth();\n    const diagnostic: ts.Diagnostic = {\n        file: node.getSourceFile().compilerNode,\n        start: start,\n        length: length,\n        messageText: messageText,\n        category: ts.DiagnosticCategory.Error,\n        code: code,\n        source: 'Genies',\n    };\n    diagnostics.push(diagnostic);\n}\n","import {GeniesLSPContext} from \"./plugins/GeniesLSPContext\";\nimport {\n    BinaryExpression, ClassDeclaration,\n    Node,\n    PostfixUnaryExpression,\n    PrefixUnaryExpression, SyntaxKind,\n    Type, TypeChecker, TypeFlags\n} from \"ts-morph\";\nimport {\n    getIsUnityAPIType,\n    typesAreEqual\n} from \"./CompilerUtils\";\n\n// Modify to return the type if the operator method exists\nexport function getOperatorMethodReturnType(typeChecker : TypeChecker,\n                                            type: Type,\n                                            operatorMethodName: string,\n                                            rightType: Type): Type | null {\n    const typeSymbol = type.getSymbol();\n    if (!typeSymbol) {\n        return null;\n    }\n\n    const declarations = typeSymbol.getDeclarations();\n    for (const declaration of declarations) {\n        if (Node.isClassDeclaration(declaration)) {\n            const classDeclaration = declaration as ClassDeclaration;\n            const methods = classDeclaration.getMethods().filter(m => m.getName() === operatorMethodName && m.getTypeParameters().length === 0);\n\n            for (const method of methods) {\n                const parameters = method.getParameters();\n                if (parameters.length === 2) {\n                    const leftParameterType = parameters[0].getType();\n                    const rightParameterType = parameters[1].getType();\n\n                    const hasRightType = typesAreEqual(rightParameterType, rightType) || typeChecker.isTypeAssignableTo(rightType, rightParameterType);\n                    const hasLeftType = typesAreEqual(leftParameterType, type) || typeChecker.isTypeAssignableTo(type, leftParameterType);\n\n                    if (hasLeftType && hasRightType) {\n                        return method.getReturnType();\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nexport function getOperatorMethodName(\n    operatorKind: SyntaxKind,\n    isUnary: boolean = false\n): string | undefined {\n    if (isUnary) {\n        // Handle unary operators:\n        switch (operatorKind) {\n            case SyntaxKind.MinusToken:\n                // -a\n                return \"op_UnaryNegation\";\n            case SyntaxKind.PlusToken:\n                // +a\n                return \"op_UnaryPlus\";\n            case SyntaxKind.ExclamationToken:\n                // !a\n                return \"op_LogicalNot\";\n            case SyntaxKind.TildeToken:\n                // ~a\n                return \"op_OnesComplement\";\n            case SyntaxKind.PlusPlusToken:\n                // ++a or a++\n                return \"op_Increment\";\n            case SyntaxKind.MinusMinusToken:\n                // --a or a--\n                return \"op_Decrement\";\n            default:\n                return undefined;\n        }\n    } else {\n        // Handle binary operators:\n        switch (operatorKind) {\n            case SyntaxKind.PlusToken:\n                // a + b\n                return \"op_Addition\";\n            case SyntaxKind.MinusToken:\n                // a - b\n                return \"op_Subtraction\";\n            case SyntaxKind.AsteriskToken:\n                // a * b\n                return \"op_Multiply\";\n            case SyntaxKind.SlashToken:\n                // a / b\n                return \"op_Division\";\n            case SyntaxKind.PercentToken:\n                // a % b\n                return \"op_Modulus\";\n            case SyntaxKind.EqualsEqualsToken:\n            case SyntaxKind.EqualsEqualsEqualsToken:\n                // a == b\n                return \"op_Equality\";\n            case SyntaxKind.ExclamationEqualsToken:\n            case SyntaxKind.ExclamationEqualsEqualsToken:\n                // a != b\n                return \"op_Inequality\";\n            case SyntaxKind.GreaterThanToken:\n                // a > b\n                return \"op_GreaterThan\";\n            case SyntaxKind.LessThanToken:\n                // a < b\n                return \"op_LessThan\";\n            case SyntaxKind.GreaterThanEqualsToken:\n                // a >= b\n                return \"op_GreaterThanOrEqual\";\n            case SyntaxKind.LessThanEqualsToken:\n                // a <= b\n                return \"op_LessThanOrEqual\";\n            case SyntaxKind.BarToken:\n                // a | b\n                return \"op_BitwiseOr\";\n            case SyntaxKind.AmpersandToken:\n                // a & b\n                return \"op_BitwiseAnd\";\n            case SyntaxKind.CaretToken:\n                // a ^ b\n                return \"op_ExclusiveOr\";\n            case SyntaxKind.LessThanLessThanToken:\n                // a << b\n                return \"op_LeftShift\";\n            case SyntaxKind.GreaterThanGreaterThanToken:\n                // a >> b\n                return \"op_RightShift\";\n            // Add additional binary operators if needed.\n            default:\n                return undefined;\n        }\n    }\n}\n\nexport function unwrapParenthesizedExpression(node: Node): Node {\n    if (Node.isParenthesizedExpression(node)) {\n        return unwrapParenthesizedExpression(node.getExpression());\n    }\n    return node;\n}\n\nexport function isCompoundAssignment(operatorKind: SyntaxKind): boolean {\n    return operatorKind >= SyntaxKind.FirstCompoundAssignment && operatorKind <= SyntaxKind.LastCompoundAssignment;\n}\n\nexport function getEquivalentOperatorForCompound(compoundOperatorKind: SyntaxKind): SyntaxKind {\n    switch (compoundOperatorKind) {\n        case SyntaxKind.PlusEqualsToken:\n            return SyntaxKind.PlusToken;\n        case SyntaxKind.MinusEqualsToken:\n            return SyntaxKind.MinusToken;\n        case SyntaxKind.AsteriskEqualsToken:\n            return SyntaxKind.AsteriskToken;\n        case SyntaxKind.SlashEqualsToken:\n            return SyntaxKind.SlashToken;\n        case SyntaxKind.PercentEqualsToken:\n            return SyntaxKind.PercentToken;\n        case SyntaxKind.AmpersandEqualsToken:\n            return SyntaxKind.AmpersandToken;\n        case SyntaxKind.BarEqualsToken:\n            return SyntaxKind.BarToken;\n        case SyntaxKind.CaretEqualsToken:\n            return SyntaxKind.CaretToken;\n        case SyntaxKind.LessThanLessThanEqualsToken:\n            return SyntaxKind.LessThanLessThanToken;\n        case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n            return SyntaxKind.GreaterThanGreaterThanToken;\n        case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n            return SyntaxKind.GreaterThanGreaterThanGreaterThanToken;\n        default:\n            throw new Error(`Unsupported compound operator: ${SyntaxKind[compoundOperatorKind]}`);\n    }\n}\n\n// Modify to return the type if the unary operator method exists\nexport function getUnaryOperatorMethodReturnType(type: Type, operatorMethodName: string): Type | null {\n    const typeSymbol = type.getSymbol();\n    if (!typeSymbol) {\n        return null;\n    }\n\n    const declarations = typeSymbol.getDeclarations();\n    for (const declaration of declarations) {\n        if (Node.isClassDeclaration(declaration)) {\n            const classDeclaration = declaration as ClassDeclaration;\n            const methods = classDeclaration.getMethods().filter(m => m.getName() === operatorMethodName && m.getTypeParameters().length === 0);\n\n            for (const method of methods) {\n                const parameters = method.getParameters();\n                if (parameters.length === 1) {\n                    const operandType = parameters[0].getType();\n                    if (operandType.getText() === type.getText()) {\n                        return method.getReturnType();\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nexport function getOperatorNodeReturnType(node: Node, context: GeniesLSPContext): Type | null {\n    if (Node.isBinaryExpression(node)) {\n        return getBinaryOperatorNodeReturnType(node, context);\n    } else if (Node.isPrefixUnaryExpression(node) || Node.isPostfixUnaryExpression(node)) {\n        return getUnaryOperatorNodeReturnType(node, context);\n    }\n\n    return null;\n}\n\nfunction unwrapType(node: Node, context: GeniesLSPContext): Type | null {\n\n    if (Node.isBinaryExpression(node)) {\n        return getBinaryOperatorNodeReturnType(node, context);\n    } else if (Node.isPrefixUnaryExpression(node) || Node.isPostfixUnaryExpression(node)) {\n        return getUnaryOperatorNodeReturnType(node, context);\n    }\n\n    return context.TypeChecker.getTypeAtLocation(node);\n}\n\nfunction getBinaryOperatorNodeReturnType(node: BinaryExpression, context: GeniesLSPContext): Type | null {\n    const operatorToken = node.getOperatorToken();\n    const operatorKind = operatorToken.getKind();\n    let operatorMethodName = getOperatorMethodName(operatorKind);\n\n    if (isCompoundAssignment(operatorKind)) {\n        const equivalentOperatorKind = getEquivalentOperatorForCompound(operatorKind);\n        operatorMethodName = getOperatorMethodName(equivalentOperatorKind);\n    }\n\n    if (operatorMethodName == null) {\n        return null;\n    }\n\n    // Ignore transformations for '== null' and '== undefined'\n    if (operatorKind === SyntaxKind.EqualsEqualsEqualsToken\n        || operatorKind === SyntaxKind.EqualsEqualsToken\n        || operatorKind === SyntaxKind.ExclamationEqualsEqualsToken\n        || operatorKind == SyntaxKind.ExclamationEqualsToken) {\n        const right = unwrapParenthesizedExpression(node.getRight());\n        if (Node.isNullLiteral(right) || Node.isUndefinedKeyword(right)) {\n            return null;\n        }\n\n        const left = unwrapParenthesizedExpression(node.getLeft());\n        if (Node.isNullLiteral(left) || Node.isUndefinedKeyword(left)) {\n            return null;\n        }\n    }\n\n    const left = unwrapParenthesizedExpression(node.getLeft());\n    const right = unwrapParenthesizedExpression(node.getRight());\n\n    let leftType = unwrapType(left, context);\n    let rightType = unwrapType(right, context);\n\n    if (leftType == null || rightType == null) {\n        return null;\n    }\n\n    if (rightType.isLiteral()) {\n        rightType = context.TypeChecker.getBaseTypeOfLiteralType(rightType);\n    }\n\n    if (leftType.isLiteral()) {\n        leftType = context.TypeChecker.getBaseTypeOfLiteralType(leftType);\n    }\n\n    if (!getIsUnityAPIType(leftType) && !getIsUnityAPIType(rightType)) {\n        return context.TypeChecker.getTypeAtLocation(node);\n    }\n\n    const leftReturnType = getOperatorMethodReturnType(context.TypeChecker, leftType, operatorMethodName, rightType);\n    const rightReturnType = getOperatorMethodReturnType(context.TypeChecker, rightType, operatorMethodName, leftType);\n\n    if (leftReturnType == null && rightReturnType == null) {\n        return null;\n    }\n\n    // Handle compound assignments (+=, -=, etc.)\n    if (isCompoundAssignment(operatorKind)) {\n        const equivalentOperatorKind = getEquivalentOperatorForCompound(operatorKind);\n        const equivalentOperatorMethodName = getOperatorMethodName(equivalentOperatorKind);\n\n        if (equivalentOperatorMethodName == null) {\n            return null;\n        }\n\n        return getOperatorMethodReturnType(context.TypeChecker, leftType, equivalentOperatorMethodName, rightType);\n    }\n\n    return leftReturnType ?? rightReturnType;\n}\n\nfunction getUnaryOperatorNodeReturnType(node: PrefixUnaryExpression | PostfixUnaryExpression, context: GeniesLSPContext): Type | null {\n    const operand = unwrapParenthesizedExpression(node.getOperand());\n    const operatorKind = node.getOperatorToken();\n    const operatorMethodName = getOperatorMethodName(operatorKind, true);\n\n    if (operatorMethodName) {\n        const operandType = context.TypeChecker.getTypeAtLocation(operand);\n        return getUnaryOperatorMethodReturnType(operandType, operatorMethodName);\n    }\n\n    return null;\n}\n","import ts from \"typescript/lib/tsserverlibrary\";\nimport {Project, SourceFile, TypeChecker} from \"ts-morph\";\nimport {Node, Type} from \"ts-morph\";\n\nexport class GeniesLSPContext {\n    private readonly project: Project;\n    private readonly info: ts.server.PluginCreateInfo;\n    private inferredTypesCache: Map<Node, Type>;\n\n    constructor(project: Project, info: ts.server.PluginCreateInfo) {\n        this.project = project;\n        this.info = info;\n        this.inferredTypesCache = new Map<Node, Type>();\n    }\n\n    get LanguageServiceHost(): ts.LanguageServiceHost {\n        return this.info.languageServiceHost;\n    }\n\n    get LanguageService(): ts.LanguageService {\n        return this.info.languageService;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.info.project.projectService.logger;\n    }\n\n    get TypeChecker(): TypeChecker {\n        return this.project.getTypeChecker();\n    }\n\n    /**\n     * Retrieves a source file. If it doesn't exist, adds it to the project.\n     * Updates the source file content with the in-memory snapshot.\n     * @param fileName The name of the file.\n     * @returns The SourceFile or undefined.\n     */\n    getSourceFile(fileName: string): SourceFile | undefined {\n        let sourceFile = this.project.getSourceFile(fileName);\n        const snapshot = this.getInMemoryFileContent(fileName, this.info.languageServiceHost);\n\n        if (!sourceFile) {\n            if (snapshot) {\n                sourceFile = this.project.createSourceFile(fileName, snapshot, {overwrite: true});\n            } else {\n                sourceFile = this.project.addSourceFileAtPath(fileName);\n            }\n\n            if (!sourceFile) {\n                this.Logger.info(\"Source file not found.\");\n                return undefined;\n            }\n        } else {\n            // Update the content with the snapshot\n            if (snapshot) {\n                sourceFile.replaceWithText(snapshot);\n            } else {\n                // If snapshot is unavailable, refresh from file system\n                sourceFile.refreshFromFileSystemSync();\n            }\n        }\n\n        return sourceFile;\n    }\n\n    /**\n     * Retrieves the content of an in-memory file.\n     * @param fileName The name of the file.\n     * @param languageServiceHost The language service host.\n     * @returns The file content or undefined.\n     */\n    private getInMemoryFileContent(fileName: string, languageServiceHost: ts.LanguageServiceHost): string | undefined {\n        const scriptSnapshot = languageServiceHost.getScriptSnapshot(fileName);\n        return scriptSnapshot ? scriptSnapshot.getText(0, scriptSnapshot.getLength()) : undefined;\n    }\n\n    /**\n     * Registers an inferred type for a given node in the cache.\n     * @param node The AST node.\n     * @param type The inferred TypeScript type.\n     */\n    setInferredType(node: Node, type: Type): void {\n        this.inferredTypesCache.set(node, type);\n    }\n\n    /**\n     * Retrieves the inferred type for a given node from the cache.\n     * @param node The AST node.\n     * @returns The inferred TypeScript type or undefined.\n     */\n    getInferredType(node: Node): Type | undefined {\n        return this.inferredTypesCache.get(node);\n    }\n\n    /**\n     * Clears the inferred types cache. Useful when the project changes.\n     */\n    clearInferredTypes(): void {\n        this.inferredTypesCache.clear();\n    }\n}\n","import ts, { DiagnosticWithLocation} from 'typescript/lib/tsserverlibrary';\nimport {ILanguageServiceFeature} from './ILanguageServiceFeature';\nimport {isGeniesScriptType} from \"../CompilerUtils\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\nexport class GeniesScriptTypeDiagnostics implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetSuggestionDiagnostics = proxy.getSuggestionDiagnostics;\n        proxy.getSuggestionDiagnostics = (fileName: string): ts.DiagnosticWithLocation[] => {\n            const diagnostics = originalGetSuggestionDiagnostics(fileName);\n            return this.getSuggestionDiagnostics(diagnostics, fileName);\n        };\n    }\n\n    private getSuggestionDiagnostics(existingDiagnostics: DiagnosticWithLocation[], fileName: string): DiagnosticWithLocation[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return existingDiagnostics;\n        }\n\n        const specialClasses = sourceFile.getClasses()\n            .filter(cls => isGeniesScriptType(cls.getType()));\n\n\n        specialClasses.forEach(cls => {\n            const diagnosticsToRemove = existingDiagnostics.filter(diagnostic => {\n                this.Logger.info(`found class ${cls.getName()} with range ${cls.getStart()} - ${cls.getEnd()}`);\n                this.Logger.info(`Code = ${diagnostic.code}`);\n                this.Logger.info(`Diagnostic start = ${diagnostic.start}`);\n                this.Logger.info(`Diagnostic Message = ${diagnostic.messageText}`);\n                \n                return diagnostic.code === 6196 && diagnostic.start >= cls.getStart() && diagnostic.start <= cls.getEnd();\n            });\n\n            diagnosticsToRemove.forEach(diagnostic => {\n                const index = existingDiagnostics.indexOf(diagnostic);\n                if (index > -1) {\n                    existingDiagnostics.splice(index, 1);\n                }\n            });\n        });\n\n        return existingDiagnostics;\n    }\n\n}\n","module.exports = require(\"ts-morph\");","import ts from 'typescript/lib/tsserverlibrary';\nimport {ClassDeclaration, Node, SourceFile, SyntaxKind} from 'ts-morph';\nimport {ILanguageServiceFeature} from './ILanguageServiceFeature';\nimport {GeniesScriptType, getGeniesScriptTypeFromType} from \"../CompilerUtils\";\nimport {ScriptableObjectAllowedMethods, unityLifecycleMethods} from \"./GeniesLifecycleEvents\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\ntype getCompletionsAtPosition = (\n    fileName: string,\n    position: number,\n    options: ts.GetCompletionsAtPositionOptions | undefined\n) => ts.CompletionInfo | undefined;\n\ntype getCompletionEntryDetails = (\n    fileName: string,\n    position: number,\n    name: string,\n    formatOptions: ts.FormatCodeOptions | ts.FormatCodeSettings | undefined,\n    source: string | undefined,\n    preferences: ts.UserPreferences | undefined,\n    data: ts.CompletionEntryData | undefined\n) => ts.CompletionEntryDetails | undefined;\n\nexport class GeniesLifecycleEventsCompletions implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetCompletionsAtPosition = proxy.getCompletionsAtPosition;\n        proxy.getCompletionsAtPosition = (\n            fileName: string,\n            position: number,\n            options: ts.GetCompletionsAtPositionOptions | undefined\n        ): ts.CompletionInfo | undefined => {\n            return this.getCompletionsAtPosition(originalGetCompletionsAtPosition, fileName, position, options);\n        };\n\n        const originalGetCompletionEntryDetails = proxy.getCompletionEntryDetails;\n        proxy.getCompletionEntryDetails = (\n            fileName: string,\n            position: number,\n            name: string,\n            formatOptions: ts.FormatCodeOptions | ts.FormatCodeSettings | undefined,\n            source: string | undefined,\n            preferences: ts.UserPreferences | undefined,\n            data: ts.CompletionEntryData | undefined\n        ): ts.CompletionEntryDetails | undefined => {\n            return this.getCompletionEntryDetails(\n                originalGetCompletionEntryDetails,\n                fileName,\n                position,\n                name,\n                formatOptions,\n                source,\n                preferences,\n                data\n            );\n        };\n    }\n\n    getCompletionsAtPosition(\n        previousGetter: getCompletionsAtPosition,\n        fileName: string,\n        position: number,\n        options: ts.GetCompletionsAtPositionOptions | undefined\n    ): ts.CompletionInfo | undefined {\n        this.Logger.info(\"Getting completions at position.\");\n\n        const prior = previousGetter(fileName, position, options);\n        const completions: ts.CompletionEntry[] = [];\n\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return prior;\n        }\n\n        const filteredPriorEntries = prior?.entries.filter(entry => !unityLifecycleMethods.find(a => a.name === entry.name)) ?? [];\n\n        const relevantMethods = this.getRelevantMethods(sourceFile, position);\n        if (relevantMethods) {\n            completions.push(\n                ...relevantMethods.map(method => {\n                    // Construct the insertText using snippet syntax\n                    const insertText = `private ${method.name}(${method.parameters}) {\\n${method.description}\\t$0\\n}`;\n\n                    // Create the completion entry\n                    return {\n                        name: method.name,\n                        kind: ts.ScriptElementKind.memberFunctionElement,\n                        kindModifiers: 'private',\n                        sortText: '0',\n                        insertText: insertText,\n                        labelDetails: {\n                            description: method.description,\n                        },\n                        isSnippet: true as const,\n                        hasAction: true as const,\n                    } as ts.CompletionEntry;\n                })\n            );\n        }\n\n\n        this.Logger.info(\"Adding completions for Unity lifecycle methods.\");\n\n        return {\n            isGlobalCompletion: prior?.isGlobalCompletion ?? false,\n            isMemberCompletion: prior?.isMemberCompletion ?? false,\n            isNewIdentifierLocation: prior?.isNewIdentifierLocation ?? false,\n            entries: [...(filteredPriorEntries ?? []), ...completions],\n        };\n    }\n    \n    getCompletionEntryDetails(\n        previousGetter: getCompletionEntryDetails,\n        fileName: string,\n        position: number,\n        name: string,\n        formatOptions: ts.FormatCodeOptions | ts.FormatCodeSettings | undefined,\n        source: string | undefined,\n        preferences: ts.UserPreferences | undefined,\n        data: ts.CompletionEntryData | undefined\n    ): ts.CompletionEntryDetails | undefined {\n        const prior = previousGetter(fileName, position, name, formatOptions, source, preferences, data);\n        if (prior) {\n            return prior;\n        }\n\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return prior;\n        }\n\n        const relevantMethods = this.getRelevantMethods(sourceFile, position);\n        if (!relevantMethods) {\n            return prior;\n        }\n\n        const method = relevantMethods.find(m => m.name === name);\n        if (method) {\n            const displayParts: ts.SymbolDisplayPart[] = [\n                { text: \"private\", kind: \"keyword\" },\n                { text: \" \", kind: \"space\" },\n                { text: method.name, kind: \"methodName\" },\n                { text: \"(\", kind: \"punctuation\" },\n            ];\n\n            if (method.parameters) {\n                const params = method.parameters.split(',').map(param => param.trim());\n                for (let i = 0; i < params.length; i++) {\n                    const [paramName, paramType] = params[i].split(':').map(s => s.trim());\n                    displayParts.push({ text: paramName, kind: \"parameterName\" });\n                    displayParts.push({ text: \": \", kind: \"punctuation\" });\n                    displayParts.push({ text: paramType, kind: \"type\" });\n                    if (i < params.length - 1) {\n                        displayParts.push({ text: \", \", kind: \"punctuation\" });\n                    }\n                }\n            }\n\n            displayParts.push({ text: \")\", kind: \"punctuation\" });\n            displayParts.push({ text: \" \", kind: \"space\" });\n\n            const changes = this.createImportChanges(sourceFile, method.imports);\n\n            return {\n                name: method.name,\n                kind: ts.ScriptElementKind.memberFunctionElement,\n                kindModifiers: 'private',\n                displayParts: displayParts,\n                documentation: [{ text: method.description, kind: \"text\" }],\n                tags: [],\n                codeActions: changes.length > 0 ? [\n                    {\n                        description: `Add necessary imports for ${method.name}`,\n                        changes: changes,\n                    },\n                ] : undefined,\n            };\n        }\n\n        return undefined;\n    }\n\n    createImportChanges(\n        sourceFile: SourceFile,\n        imports: { type: string; module: string }[]\n    ): ts.CodeAction['changes'] {\n        const changes: ts.FileTextChanges[] = [];\n\n        // Gather existing imports\n        const importMap = new Map<string, Set<string>>();\n        sourceFile.getImportDeclarations().forEach(importDecl => {\n            const moduleSpecifier = importDecl.getModuleSpecifierValue();\n            const namedImports = new Set(importDecl.getNamedImports().map(namedImport => namedImport.getName()));\n            importMap.set(moduleSpecifier, namedImports);\n        });\n\n        // Update or add new imports\n        imports.forEach(imp => {\n            const existingImports = importMap.get(imp.module);\n            if (existingImports) {\n                if (!existingImports.has(imp.type)) {\n                    existingImports.add(imp.type);\n                }\n            } else {\n                importMap.set(imp.module, new Set([imp.type]));\n            }\n        });\n\n        // Convert import map to text changes\n        importMap.forEach((namedImports, moduleSpecifier) => {\n            const existingImport = sourceFile.getImportDeclaration(moduleSpecifier);\n            if (existingImport) {\n                const existingNamedImports = existingImport.getNamedImports().map(namedImport => namedImport.getName());\n                const newImports = Array.from(namedImports).filter(name => !existingNamedImports.includes(name));\n                if (newImports.length > 0) {\n                    const lastNamedImport = existingImport.getNamedImports().pop();\n                    if (lastNamedImport) {\n                        changes.push({\n                            fileName: sourceFile.getFilePath(),\n                            textChanges: [{\n                                newText: `, ${newImports.join(', ')}`,\n                                span: { start: lastNamedImport.getEnd(), length: 0 },\n                            }],\n                        });\n                    }\n                }\n            } else {\n                changes.push({\n                    fileName: sourceFile.getFilePath(),\n                    textChanges: [{\n                        newText: `import { ${Array.from(namedImports).join(', ')} } from '${moduleSpecifier}';\\n`,\n                        span: { start: 0, length: 0 },\n                    }],\n                });\n            }\n        });\n\n        return changes;\n    }\n\n    getRelevantMethods(\n        sourceFile: SourceFile,\n        position: number\n    ): Array<{\n        description: string;\n        name: string;\n        parameters: string;\n        imports: { type: string; module: string }[];\n    }> | undefined {\n        const node = sourceFile.getDescendantAtPos(position);\n        if (node) {\n            const classDeclaration = this.getEnclosingClassDeclaration(node, position);\n\n            if (classDeclaration) {\n                // Check if the position is within the class body\n                if (!this.isPositionInClassBodyOnly(classDeclaration, position)) {\n                    return undefined;\n                }\n\n                const type = classDeclaration.getType();\n\n                const geniesScriptType = getGeniesScriptTypeFromType(type);\n\n                if (geniesScriptType === GeniesScriptType.None) {\n                    this.Logger.info(\"No relevant methods found for the script type.\");\n                    return undefined;\n                }\n\n                const existingMethods = classDeclaration.getMethods().map(m => m.getName());\n                const unusedUnityMethods = unityLifecycleMethods.filter(um => !existingMethods.includes(um.name));\n\n                let relevantMethods: typeof unityLifecycleMethods = [];\n\n                if (geniesScriptType === GeniesScriptType.Monobehaviour) {\n                    relevantMethods = unusedUnityMethods;\n                } else if (geniesScriptType === GeniesScriptType.ScriptableObject) {\n                    relevantMethods = unusedUnityMethods.filter(method => ScriptableObjectAllowedMethods.includes(method.name));\n                }\n\n                return relevantMethods;\n            }\n        }\n\n        return undefined;\n    }\n\n    getEnclosingClassDeclaration(node: Node, position: number): ClassDeclaration | undefined {\n        let current: Node | undefined = node;\n        while (current) {\n            if (Node.isClassDeclaration(current)) {\n                const classStart = current.getStart();\n                const classEnd = current.getEnd();\n                if (classStart <= position && position <= classEnd) {\n                    return current as ClassDeclaration;\n                }\n            }\n            current = current.getParent();\n        }\n        return undefined;\n    }\n    isPositionInClassBodyOnly(classDeclaration: ClassDeclaration, position: number): boolean {\n        const openBraceToken = classDeclaration.getFirstChildByKind(SyntaxKind.OpenBraceToken);\n        const closeBraceToken = classDeclaration.getFirstChildByKind(SyntaxKind.CloseBraceToken);\n\n        if (!openBraceToken || !closeBraceToken) {\n            return false; // No class body braces, so nothing to complete within\n        }\n\n        const bodyStart = openBraceToken.getEnd();\n        const bodyEnd = closeBraceToken.getStart();\n\n        // Check if the position is within the class body boundaries\n        if (position < bodyStart || position > bodyEnd) {\n            return false;\n        }\n\n        // Get the node at the position and ensure it's directly within the class body scope\n        const nodeAtPosition = classDeclaration.getSourceFile().getDescendantAtPos(position);\n        if (!nodeAtPosition) return false;\n\n        const parent = nodeAtPosition.getParent();\n        const grandparent = parent?.getParent();\n\n        // Check if the node's parent is the class or the opening/closing brace, indicating it's in the class body\n        if (parent === classDeclaration || parent === openBraceToken || parent === closeBraceToken || grandparent === classDeclaration) {\n            return true;\n        }\n\n        return false; // Otherwise, the position is likely inside a member\n    }\n\n}\n","import ts, {DiagnosticWithLocation} from 'typescript/lib/tsserverlibrary';\nimport {ILanguageServiceFeature} from './ILanguageServiceFeature';\nimport {unityLifecycleMethods} from './GeniesLifecycleEvents';\nimport {isGeniesScriptType} from \"../CompilerUtils\";\nimport {GeniesLSPContext} from \"./GeniesLSPContext\";\n\nexport class GeniesLifecycleEventsDiagnostics implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetSuggestionDiagnostics = proxy.getSuggestionDiagnostics;\n        proxy.getSuggestionDiagnostics = (fileName: string): ts.DiagnosticWithLocation[] => {\n            const diagnostics = originalGetSuggestionDiagnostics(fileName);\n            return this.getSuggestionDiagnostics(diagnostics, fileName);\n        };\n    }\n\n    private getSuggestionDiagnostics(existingDiagnostics: DiagnosticWithLocation[], fileName: string): DiagnosticWithLocation[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if(!sourceFile)\n        {\n            return existingDiagnostics;\n        }\n        \n        const unityMethodNames = new Set(unityLifecycleMethods.map(method => method.name));\n        const specialMethods = sourceFile.getClasses()\n            .filter(cls => isGeniesScriptType(cls.getType()))\n            .flatMap(cls => cls.getMethods())\n            .filter(m => unityMethodNames.has(m.getName()));\n\n        specialMethods.forEach(method => {\n            const diagnosticsToRemove = existingDiagnostics.filter(diagnostic => {\n                return diagnostic.code === 6133 && diagnostic.start === method.getNameNode().getStart();\n            });\n            diagnosticsToRemove.forEach(diagnostic => {\n                const index = existingDiagnostics.indexOf(diagnostic);\n                if (index > -1) {\n                    existingDiagnostics.splice(index, 1);\n                }\n            });\n        });\n\n        return existingDiagnostics;\n    }\n}\n","import ts from 'typescript/lib/tsserverlibrary';\nimport { ILanguageServiceFeature } from './ILanguageServiceFeature';\nimport { GeniesLSPContext } from \"./GeniesLSPContext\";\nimport {getGeniesSemanticDiagnostics} from \"../GeniesDiagnosticsUtils\";\n\nexport class GeniesSemanticDiagnostics implements ILanguageServiceFeature {\n    private readonly context: GeniesLSPContext;\n\n    constructor(context: GeniesLSPContext) {\n        this.context = context;\n    }\n\n    get Logger(): ts.server.Logger {\n        return this.context.Logger;\n    }\n\n    enhanceProxy(proxy: ts.LanguageService): void {\n        const originalGetSemanticDiagnostics = proxy.getSemanticDiagnostics;\n        proxy.getSemanticDiagnostics = (fileName: string): ts.Diagnostic[] => {\n            let diagnostics = originalGetSemanticDiagnostics(fileName);\n            diagnostics = this.getGeniesSemanticDiagnostics(diagnostics, fileName);\n            return diagnostics;\n        };\n    }\n\n    private getGeniesSemanticDiagnostics(existingDiagnostics: ts.Diagnostic[], fileName: string): ts.Diagnostic[] {\n        const sourceFile = this.context.getSourceFile(fileName);\n        if (!sourceFile) {\n            return existingDiagnostics;\n        }\n\n        // Clear existing diagnostics to prevent duplicate additions\n        const newDiagnostics: ts.Diagnostic[] = getGeniesSemanticDiagnostics(sourceFile, this.context.TypeChecker);\n        \n        // Remove previous diagnostics that share the same message and range\n        const uniqueExistingDiagnostics = existingDiagnostics.filter(existingDiag =>\n            !newDiagnostics.some(newDiag =>\n                newDiag.messageText === existingDiag.messageText &&\n                newDiag.start === existingDiag.start &&\n                newDiag.length === existingDiag.length\n            )\n        );\n\n        return [...uniqueExistingDiagnostics, ...newDiagnostics];\n    }\n}\n","module.exports = require(\"path\");","module.exports = require(\"typescript/lib/tsserverlibrary\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(26);\n"],"names":["root","factory","exports","module","define","amd","this","modules","project","context","create","info","projectService","logger","Project","compilerOptions","getCompilerOptions","skipAddingFilesFromTsConfig","setProjectRoot","getFileSystem","getCurrentDirectory","GeniesLSPContext","features","GeniesLifecycleEventsCompletions","CSharpOperatorOverloadingSuppress","GeniesLifecycleEventsDiagnostics","GeniesScriptTypeDiagnostics","GeniesSemanticDiagnostics","proxy","Object","k","keys","languageService","x","args","apply","forEach","feature","enhanceProxy","constructor","expressionValidity","Logger","originalGetSemanticDiagnostics","getSemanticDiagnostics","fileName","previousGetter","priorDiagnostics","sourceFile","getSourceFile","collectExpressions","diagnostics","filter","diagnostic","undefined","start","length","end","code","OPERATOR_ERROR_CODES","includes","Number","expr","valid","binaryExpressions","getDescendantsOfKind","SyntaxKind","BinaryExpression","prefixUnaryExpressions","PrefixUnaryExpression","postfixUnaryExpressions","PostfixUnaryExpression","processNode","node","getStart","getEnd","finalType","getOperatorNodeReturnType","getText","push","assignmentExpressions","getOperatorToken","getKind","EqualsToken","assign","rhs","getRight","rhsStart","rhsEnd","some","variableDecls","VariableDeclaration","v","init","getInitializer","initStart","initEnd","asExpressions","AsExpression","asExp","subExp","getExpression","subStart","subEnd","subType","TypeChecker","getTypeAtLocation","castType","getTypeNodeOrThrow","isAssignableTo","unityLifecycleMethods","name","parameters","description","imports","type","ScriptableObjectAllowedMethods","propertyInfoCache","Map","GeniesScriptUiEvents","projectRoot","GeniesDeclarationFileAnnotation","GeniesInstancePropName","MonobehaviourTypeName","ScriptableObjectTypeName","NonSerializedDecorator","SerializeFieldDecorator","GET_ITEM_NAME","SET_ITEM_NAME","componentMethods","Set","AllowedUiInterfaces","UiInterfaceToEnumMap","PointerClick","PointerDown","PointerEnter","PointerExit","PointerUp","BeginDrag","Deselect","Drag","Drop","EndDrag","InitializePotentialDrag","Scroll","Select","Submit","UpdateSelected","Move","Cancel","AliasToTypeName","AliasToFullTypeName","GeniesScriptType","extendsMonoBehaviour","classDecl","baseClass","getBaseClass","getName","extendsScriptableObject","typesAreEqual","type1","type2","cleanTypeText","inheritsFrom","baseNames","typeChecker","baseTypes","getBaseTypes","baseType","baseTypeName","getSymbol","visited","symbol","declarations","getDeclarations","declaration","Node","isClassDeclaration","heritageClauses","getHeritageClauses","heritageClause","typeNodes","getTypeNodes","typeNode","has","add","getGenericTypeKey","typeArguments","getTypeName","map","t","tArgs","getTypeArguments","join","getTypeNameAndEnsureImported","typeName","csTypeName","typeModule","current","get","scriptType","getGeniesScriptTypeFromType","None","Monobehaviour","ScriptableObject","getIsUnityAPIType","Error","getFullTypeName","lastDotIndex","lastIndexOf","substring","existingImport","getImportDeclarations","find","importDecl","getModuleSpecifierValue","getNamedImports","namedImport","addNamedImport","importStructure","kind","StructureKind","ImportDeclaration","moduleSpecifier","namedImports","addImportDeclaration","forCsharp","includeArguments","text","aliasSymbol","getAliasSymbol","getFullyQualifiedName","replace","isExported","decl","isInterfaceDeclaration","sourceFilePath","getFilePath","relativePath","convertToAliasPath","parsedPath","path","parse","filePathWithoutExt","dir","parsed","aliasPath","convertToGeniesAliasPath","regex","test","match","number","arg","index","argText","updateChildPaths","childProperties","parentPath","childProp","updatedChildProp","Path","Name","ChildProperties","extractProperties","cls","basePath","typeArgumentMap","className","cacheKey","getTypeParameters","p","Array","from","entries","key","value","genericArgs","cachedProperties","prop","updatedProp","properties","getProperties","visibility","getScope","decorators","extractDecorators","isStatic","isReadonly","d","Type","resolveGenericType","getType","isArray","resolvedType","resolveArrayElementType","propName","fullPath","expression","NewExpression","newExpression","getArguments","PropertyAccessExpression","pae","StringLiteral","getLiteralValue","initializerExpressions","hasInitializer","initializer","ArrayLiteralExpression","arrayLiteral","i","getElements","element","propertyInfo","TypeName","IsArray","IsEnum","EnumKeys","EnumValues","Decorators","IsGeniesBehaviourRef","IsGeniesScriptableObjectRef","Initializers","ArrayElementInitializer","ArrayDimension","dimension","getArrayElementInitializer","fillExtraPropertyInfo","set","isEnum","isUnityType","getIsUnityAPIDeclaration","geniesScriptType","getGeniesScriptTypeFromNode","values","dec","EnumDeclaration","getMembers","member","getValue","extractEnumDetails","toString","fillEnumInfo","typeParams","typeArgs","param","uniqueParamName","getCompleteTypeArgumentMap","unshift","newBase","underlyingTypeName","propPath","getArrayElementType","currentDimension","existingTypeArgumentMap","processInheritanceChain","getHeritageClauseByKind","ExtendsKeyword","baseTypeArgs","baseTypeParams","resolvedTypeArgs","uniqueBaseParamName","typeArg","isTypeParameter","isTypeParameterDeclaration","parent","getParent","parentName","typeArgNode","TypeReference","isIdentifier","uniqueDerivedParamName","parentDecl","uniqueTypeName","getIsUnityAPISourceFile","firstNode","getFirstChild","console","log","leadingComments","getLeadingCommentRanges","typeText","trim","ClassDeclaration","isMonobehaviour","isScriptableObject","absolutePath","normalizedPath","split","sep","assetsIndex","indexOf","assetsPrefix","comGeniesMatch","resolve","getDecorators","Args","a","NumericalAliases","positions","decorator","getFullStart","sort","b","replaceText","collectNodes","depth","nodes","forEachChild","child","traversePostOrder","callback","classDeclaration","resultSet","currentClass","classTypeName","getImplements","implementClause","queue","currentIfaceType","shift","ifaceName","inheritedType","allStatements","getStatements","importDeclarations","stmt","variableStatements","VariableStatement","otherStatements","newText","replaceWithText","createGenericTypeVariable","transformationContext","sourceFileGenericTypeMap","genericMap","genericKey","genericTypeName","getTypeArgNameAndEnsureImported","genericDeclaration","genericVarName","addVariableStatement","declarationKind","VariableDeclarationKind","Const","getIsValidUnityGenericTypeArg","argType","constraint","getConstraint","isClassLikeDeclarationBase","isFromExternalLibrary","isDeclarationFile","resolveName","SymbolFlags","All","getDeclaredTypeOfSymbol","isPropertyAccessExpression","isThisExpression","getNameNode","gType","filePath","getDirectoryPath","importDeclaration","startsWith","setModuleSpecifier","inferPossibleTypes","types","inferredTypeNames","brandedType","getTypeByName","getBrandedTypes","numericInfo","getNumericValue","hasDecimal","inferTypesFromNumericInfo","scoreOverload","overload","argumentTypesList","getParameters","score","paramType","argTypes","argScore","scoreParameter","possibleArgTypes","bestScore","Math","max","isTypeAssignableTo","isValidNumericalType","isNumericCastable","fromType","toType","fromTypeName","toTypeName","byte","sbyte","short","ushort","int","uint","float","double","numericLiteralInfo","getNumericLiteralInfo","isVariableDeclaration","isPropertyDeclaration","valueInfo","performFlowAnalysis","isNumericLiteral","isPrefixUnaryExpression","MinusToken","operand","getOperand","usageNode","currentValueInfo","initValueInfo","getNumericValueFromExpression","methodDeclaration","getFirstAncestorByKind","MethodDeclaration","statements","usageStart","assignments","getDescendants","isBinaryExpression","isPostfixUnaryExpression","assignment","operatorKind","left","getLeft","right","isAssignmentToSymbol","PlusEqualsToken","MinusEqualsToken","AsteriskEqualsToken","SlashEqualsToken","PercentEqualsToken","evaluateCompoundAssignment","delta","PlusPlusToken","exprSymbol","leftInfo","rightInfo","evaluateBinaryOperation","binaryOperatorKind","PlusToken","AsteriskToken","SlashToken","PercentToken","resultValue","overloads","callExpression","compatibleOverloads","constraintType","filterOverloadsByTypeArguments","callArgs","params","every","isOptional","bestOverload","highestScore","CUSTOM_DIAGNOSTIC_CODES","ALLOWED_INHERITANCE_TYPES","COMPONENT_METHODS","isTypeCompatibleWithParameter","argumentType","parameterType","addDiagnostic","messageText","getWidth","file","compilerNode","category","DiagnosticCategory","source","getClasses","implementedInterfaces","baseClassName","diagnosticMessage","intf","processClassDiagnostics","CallExpression","callExpr","methodDeclarations","methodSymbol","isMethodDeclaration","methodName","getMethodName","callArgTypes","getProject","getTypeChecker","hasMatchingNonGenericOverload","validArgs","m","typeArgType","isValidComponentTypeArg","processGenericMethodCall","propertyAccess","asKind","overloadDeclarations","isMethodSignature","selectBestOverload","methodTypeParams","hasTypeArgs","typeParamMap","min","parameter","argument","isUserDefinedType","typeParamName","checkParameterTypesForUnityApiCalls","processCallExpressionDiagnostics","newExpr","typeSymbol","classDeclarations","expectedTypeArgsCount","providedTypeArgsCount","processTypeUsageDiagnostics","getOperatorMethodReturnType","operatorMethodName","rightType","methods","getMethods","method","leftParameterType","rightParameterType","hasRightType","getReturnType","getOperatorMethodName","isUnary","ExclamationToken","TildeToken","MinusMinusToken","EqualsEqualsToken","EqualsEqualsEqualsToken","ExclamationEqualsToken","ExclamationEqualsEqualsToken","GreaterThanToken","LessThanToken","GreaterThanEqualsToken","LessThanEqualsToken","BarToken","AmpersandToken","CaretToken","LessThanLessThanToken","GreaterThanGreaterThanToken","unwrapParenthesizedExpression","isParenthesizedExpression","isCompoundAssignment","FirstCompoundAssignment","LastCompoundAssignment","getEquivalentOperatorForCompound","compoundOperatorKind","AmpersandEqualsToken","BarEqualsToken","CaretEqualsToken","LessThanLessThanEqualsToken","GreaterThanGreaterThanEqualsToken","GreaterThanGreaterThanGreaterThanEqualsToken","GreaterThanGreaterThanGreaterThanToken","getUnaryOperatorMethodReturnType","unwrapType","getBinaryOperatorNodeReturnType","getUnaryOperatorNodeReturnType","isNullLiteral","isUndefinedKeyword","leftType","isLiteral","getBaseTypeOfLiteralType","leftReturnType","rightReturnType","equivalentOperatorMethodName","inferredTypesCache","LanguageServiceHost","languageServiceHost","LanguageService","snapshot","getInMemoryFileContent","refreshFromFileSystemSync","createSourceFile","overwrite","addSourceFileAtPath","scriptSnapshot","getScriptSnapshot","getLength","setInferredType","getInferredType","clearInferredTypes","clear","originalGetSuggestionDiagnostics","getSuggestionDiagnostics","existingDiagnostics","isGeniesScriptType","splice","require","originalGetCompletionsAtPosition","getCompletionsAtPosition","position","options","originalGetCompletionEntryDetails","getCompletionEntryDetails","formatOptions","preferences","data","prior","completions","filteredPriorEntries","entry","relevantMethods","getRelevantMethods","insertText","ScriptElementKind","memberFunctionElement","kindModifiers","sortText","labelDetails","isSnippet","hasAction","isGlobalCompletion","isMemberCompletion","isNewIdentifierLocation","displayParts","paramName","s","changes","createImportChanges","documentation","tags","codeActions","importMap","imp","existingImports","getImportDeclaration","existingNamedImports","newImports","lastNamedImport","pop","textChanges","span","getDescendantAtPos","getEnclosingClassDeclaration","isPositionInClassBodyOnly","existingMethods","unusedUnityMethods","um","classStart","classEnd","openBraceToken","getFirstChildByKind","OpenBraceToken","closeBraceToken","CloseBraceToken","bodyStart","bodyEnd","nodeAtPosition","grandparent","unityMethodNames","flatMap","getGeniesSemanticDiagnostics","newDiagnostics","existingDiag","newDiag","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}